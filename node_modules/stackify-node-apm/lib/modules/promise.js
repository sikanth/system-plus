'use strict'

const util = require('util')
const Util = require('./../util')

module.exports = function (library, tracer, shimmer, promiseOptions) {
  let Promise = library[promiseOptions.classConstructor]
  wrapClassPrototypeMethods(Promise.prototype, promiseOptions.classPrototypeOptions)
  wrapClassStaticMethods(Promise, promiseOptions.classStaticOptions)
  wrapClassConstructor(library, promiseOptions.classConstructor, promiseOptions.classStaticOptions)

  function wrapClassStaticMethods (lib, classStaticOptions) {
    classStaticOptions.castMethods.forEach(function (element, index, array) {
      if (!Util.isUndefined(lib[element])) {
        shimmer.wrap(lib, element, wrapCast)
      }
    })

    function wrapCast (original, name) {
      if (!Util.isFunction(original)) {
        return original
      }

      if (Util.isMonkeyPatched(original)) {
        return original
      }

      return function wrappedCast () {
        let span = tracer.getActiveSpan()
        const promise = original.apply(this, arguments)
        if (span) {
          promise.stackifySpanInContext = span
        }
        return promise
      }
    }
  }

  function wrapClassPrototypeMethods (lib, classPrototypeOptions) {
    classPrototypeOptions.resolveMethods.forEach(function (element, index, array) {
      if (!Util.isUndefined(lib[element])) {
        shimmer.wrap(lib, element, makeContinuationWrapper(true))
      }
    })

    classPrototypeOptions.rejectMethods.forEach(function (element, index, array) {
      if (!Util.isUndefined(lib[element])) {
        shimmer.wrap(lib, element, makeContinuationWrapper(false))
      }
    })
  }

  function makeContinuationWrapper (useAllArgs) {
    return function wrapContinuation (original, name) {
      if (!Util.isFunction(original)) {
        return original
      }

      if (Util.isMonkeyPatched(original)) {
        return original
      }

      return function wrappedContinuation () {
        if (!(this instanceof Promise)) {
          return original.apply(this, arguments)
        }

        let continuationActiveSpan = tracer.getActiveSpan()
        let promise = this

        if (!promise.stackifySpanInContext && !continuationActiveSpan) {
          // No context and no active span so useless to continue
          return original.apply(this, arguments)
        }

        let isWrapped = false
        let argsArray = Util.argsToArray.apply(this, arguments)
        let argsLength = argsArray.length

        for (let index = 0; index < argsLength; index++) {
          let handler = argsArray[index]

          if (
            !Util.isFunction(handler) || // Not a function
            Util.isMonkeyPatched(handler) || // Already patched
            (!useAllArgs && index !== (argsLength - 1)) // Don't want all and not last
          ) {
            isWrapped = Util.isMonkeyPatched(handler)
            continue
          }

          shimmer.wrap(argsArray, index, wrapContinuationHandler)
        }

        let nextContinuationResult = original.apply(this, argsArray)

        // If first argument is a promise or other object
        // And the continuation result is a promise
        // And the result is not equal to the current promise context (new)
        if (!isWrapped && nextContinuationResult instanceof Promise && nextContinuationResult !== promise) {
          nextContinuationResult.stackifySpanInContext = promise.stackifySpanInContext // activeSpan or the one used by the current promise?
          // If no active span, fallback to promise span
          if (!nextContinuationResult.stackifySpanInContext) {
            nextContinuationResult.stackifySpanInContext = continuationActiveSpan
          }
        }

        return nextContinuationResult

        function wrapContinuationHandler (original, name) {
          if (!Util.isFunction(original)) {
            return original
          }

          if (Util.isMonkeyPatched(original)) {
            return original
          }

          return function wrappedContinuationHandler () {
            let continuationHandlerActiveSpan = tracer.getActiveSpan()

            // Then has no result or no context attached
            if (!nextContinuationResult || !nextContinuationResult.stackifySpanInContext) {
              return original.apply(this, arguments)
            }

            let spanInContext = nextContinuationResult.stackifySpanInContext
            let nextSpan = spanInContext

            if (!spanInContext && continuationHandlerActiveSpan && continuationHandlerActiveSpan !== nextSpan) {
              nextSpan = continuationHandlerActiveSpan
            }

            return tracer.bindSpanCallback(original, nextSpan).apply(this, arguments)
          }
        }
      }
    }
  }

  function wrapClassConstructor (lib, classConstructor, classStaticOptions) {
    shimmer.wrap(lib, classConstructor, function wrapPromiseClass (original, methodName) {
      if (!Util.isFunction(original)) {
        return original
      }

      if (Util.isMonkeyPatched(original)) {
        return original
      }

      if (classStaticOptions && classStaticOptions.copyMethods) {
        // Copy patched promise methods to the wrappedPromise
        promiseOptions.classStaticOptions.copyMethods.forEach(function (method) {
          if (!wrappedPromise[method] && Promise[method]) {
            wrappedPromise[method] = Promise[method]
          }
        })
      }

      util.inherits(wrappedPromise, Promise)

      return wrappedPromise

      function wrappedPromise (executor) {
        if (!(this instanceof wrappedPromise)) {
          return Promise(executor) // eslint-disable-line new-cap
        }

        const activeSpan = tracer.getActiveSpan()
        let promise = null

        if (
          !activeSpan || // There is no active span
          !Util.isFunction(executor) || // If executor is not a function
          arguments.length !== 1 // Not standard arguments
        ) {
          let args = Util.argsToArray.apply(this, arguments)
          args.unshift(Promise)
          promise = new (Promise.bind.apply(Promise, args))()
        } else {
          let executorContext = {
            promise: null,
            self: null,
            args: null
          }

          // Wrap executor so we can create an executor context created
          // by the real promise
          promise = new Promise(wrapExecutorContext(executorContext))
          executorContext.promise = promise // store the original promise for the context

          promise.stackifySpanInContext = activeSpan
          try {
            tracer
              .bindSpanCallback(executor, activeSpan) // Just bind the current span to the executor
              .apply(executorContext.self, executorContext.args)
          } catch (e) {
            executorContext.args[1](e) // reject with error
          } finally {
            promise.stackifySpanInContext.captureTime()
          }
        }

        promise.__proto__ = wrappedPromise.prototype // eslint-disable-line no-proto
        return promise
      }
    })
  }

  function wrapExecutorContext (context) {
    return function contextExporter (resolve, reject) {
      context.self = this // Get current context (current promise)
      context.args = Util.argsToArray.apply(this, arguments)
      context.args[0] = wrapResolver(context, resolve)
      context.args[1] = wrapResolver(context, reject)
    }
  }

  // Once resolvers are executed, update spanInContext time
  function wrapResolver (context, fn) {
    return function wrappedResolveReject (val) {
      let promise = context.promise
      if (promise && promise.stackifySpanInContext) {
        promise.stackifySpanInContext.captureTime()
      }
      fn(val)
    }
  }
}
