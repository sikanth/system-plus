'use strict'

const Logger = require('../logger')
let semver = require('semver')
let Util = require('../util')

module.exports = function (redis, tracer, shimmer, version) {
  if (!semver.satisfies(version, '^2.0.0')) {
    Logger.debug('redis version %s not supported', version)
    return redis
  }

  Logger.debug('RedisClient version %s', version)

  let proto = redis.RedisClient && redis.RedisClient.prototype
  if (semver.satisfies(version, '>2.5.3')) {
    Logger.debug('Redis:internal_send_command...')
    tracer.watch(proto, 'internal_send_command', function watchOptionsCallback () {
      return {
        spanCall: 'redis.query',
        createSpan: true,
        spanProperties: {
          PROVIDER: 'Redis',
          CATEGORY: 'Cache',
          SUBCATEGORY: 'Execute',
          COMPONENT_CATEGORY: 'Cache',
          COMPONENT_DETAIL: 'Execute'
        },
        hookOptions: {
          hookIn: function (original, args, methodName, activeSpan) {
            activeSpan.addProperty('THREAD_ID', this.threadId)
          },
          hookCheck: function (original, args, methodName) {
            let commandObj = args[0]
            if (Util.isMonkeyPatched(commandObj.callback)) {
              Logger.debug('Redis:internal_send_command - callback already wrapped, not binding')
              return false
            } else {
              Logger.debug('Redis:internal_send_command - callback already not wrapped')
              return true
            }
          }
        },
        callbackOptions: {
          wrapper: function (original, methodName, args, activeSpan) {
            let commandObj = args[0]
            let host, port
            if (typeof this.connection_options === 'object') {
              ({ host, port } = this.connection_options)
              if (host && port) activeSpan.addProperty('URL', host + ':' + port)
            }
            if (commandObj) {
              if (commandObj.command) {
                activeSpan.addProperty('OPERATION', commandObj.command)
                if (commandObj.args.length > 0) {
                  activeSpan.addProperty('CACHEKEY', commandObj.args[0])
                }
              }
              if (commandObj.callback) {
                commandObj.callback = tracer.bindSpanCallback(commandObj.callback, activeSpan, {
                  captureActiveSpanTime: true
                })
              }
            }
          }
        }
      }
    })
  } else {
    Logger.debug('Redis:send_command...')
    tracer.watch(proto, 'send_command', function watchOptionsCallback () {
      return {
        spanCall: 'redis.query',
        createSpan: true,
        spanProperties: {
          PROVIDER: 'Redis',
          CATEGORY: 'Cache',
          SUBCATEGORY: 'Execute',
          COMPONENT_CATEGORY: 'Cache',
          COMPONENT_DETAIL: 'Execute'
        },
        hookOptions: {
          hookIn: function (original, args, methodName, activeSpan) {
            activeSpan.addProperty('THREAD_ID', this.threadId)
          },
          hookCheck: function (original, args, methodName) {
            let index = args.length - 1
            let cb = args[index]
            let callback
            if (typeof cb === 'function') {
              callback = args[index]
            } else if (Array.isArray(cb) && typeof cb[cb.length - 1] === 'function') {
              callback = cb[cb.length - 1]
            }
            if (callback && Util.isMonkeyPatched(callback)) {
              Logger.debug('Redis:send_command - callback already wrapped, not binding')
              return false
            } else {
              Logger.debug('Redis:send_command - callback already not wrapped')
              return true
            }
          }
        },
        callbackOptions: {
          wrapper: function (original, methodName, args, activeSpan) {
            let index = args.length - 1
            let cb = args[index]
            if (!Util.isUndefined(args[1]) && typeof args[1][0] === 'string') {
              activeSpan.addProperty('CACHEKEY', args[1][0])
            }
            if (!Util.isUndefined(args[0])) {
              activeSpan.addProperty('OPERATION', args[0])
            }
            let host, port
            if (typeof this.connection_options === 'object') {
              ({ host, port } = this.connection_options)
              if (host && port) activeSpan.addProperty('URL', host + ':' + port)
            }
            if (typeof cb === 'function') {
              args[index] = tracer.bindSpanCallback(cb)
            } else if (Array.isArray(cb) && typeof cb[cb.length - 1] === 'function') {
              let cb2 = cb[cb.length - 1]
              cb[cb.length - 1] = tracer.bindSpanCallback(cb2)
            } else {
              let obCb = tracer.bindSpanCallback(cb)
              if (typeof args[index] === 'undefined') {
                args[index] = obCb
              } else {
                args.push(obCb)
              }
            }
          }
        }
      }
    })
  }

  return redis
}
