'use strict'

const Util = require('../../util')
const Logger = require('../../logger')

const ARGS = {
  FIRST: 0,
  SECOND: 1,
  THIRD: 2,
  LAST: -1
}

const TYPE = {
  APPLICATION: 'Application',
  ROUTE: 'Route',
  ROUTER: 'Router',
  MIDDLEWARE: 'Middleware',
  ERRORWARE: 'Errorware'
}

const ROUTE_EVENTS = {
  onRequest: true,
  onPreAuth: true,
  onCredentials: true,
  onPostAuth: true,
  onPreHandler: true,
  onPostHandler: true,
  onPreResponse: true,

  // Server events
  onPreStart: false,
  onPostStart: false,
  onPreStop: false,
  onPostStop: false
}

module.exports = function (hapi, tracer, shimmer, version) {
  tracer.wrapClassFunctionPatchReturn(hapi, 'server', {
    patchReturnCallback: wrapServerGenerator
  })
  tracer.wrapClassFunctionPatchReturn(hapi, 'Server', {
    patchReturnCallback: wrapServerGenerator
  })

  function wrapServerGenerator (ret, original, args) {
    let serverPrototype = Object.getPrototypeOf(ret)

    if (!serverPrototype) {
      return
    }

    if (Util.isMonkeyPatched(serverPrototype, 'decorate')) {
      Logger.debug('Already wrapped Server proto, not wrapping again')
      return
    }

    shimmer.wrap(serverPrototype, 'decorate', function wrapDecorate (original, name) {
      return function wrappedDecorate (type, property, method, options) {
        let args = Util.argsToArray.apply(this, arguments)

        if (type !== 'handler') {
          return original.apply(this, args)
        }

        shimmer.wrap(args, ARGS.THIRD, function wrapRouteHandlerGenerator (routeHandlerGenerator, name) {
          if (typeof routeHandlerGenerator !== 'function') {
            return routeHandlerGenerator
          }

          if (Util.getPropertyFromObject(routeHandlerGenerator, 'defaults')) {
            wrappedRouteHandlerGenerator.defaults = routeHandlerGenerator.defaults
          }

          return wrappedRouteHandlerGenerator

          function wrappedRouteHandlerGenerator () {
            let routeHandlerGeneratorArgs = Util.argsToArray.apply(this, arguments)
            let routeHandler = routeHandlerGenerator.apply(this, routeHandlerGeneratorArgs)

            if (Util.isFunction(routeHandler)) {
              let route = !Util.isUndefined(routeHandlerGeneratorArgs[0]) ? routeHandlerGeneratorArgs[0] : null
              return wrapRouteHandler('Decorate.Handler', routeHandler, route && route.path)
            }

            return routeHandler
          }
        })

        return original.apply(this, args)
      }
    })

    shimmer.wrap(serverPrototype, 'route', function wrapRoute (original, name) {
      return function wrappedRoute () {
        let args = Util.argsToArray.apply(this, arguments)

        // first argument is expected to be the route configuration object
        if (!Util.isObject(args[ARGS.FIRST])) {
          return original.apply(this, args)
        }

        // If route is created via a plugin, pull prefix if it exists
        const pluginPrefix = (
          this.realm &&
          this.realm.modifiers &&
          this.realm.modifiers.route &&
          this.realm.modifiers.route.prefix
        ) || ''

        makeWrappedRoute(args[ARGS.FIRST], pluginPrefix)

        return original.apply(this, args)

        function makeWrappedRoute (route, pluginPrefix) {
          const routePath = pluginPrefix + route.path
          if (Util.isArray(route)) {
            for (let i = 0; i < route.length; ++i) {
              makeWrappedRoute(route[i], pluginPrefix)
            }
            return
          } else if (route.options) {
            if (route.options.pre) {
              route.options.pre = wrapPreRouteHandlers('Route.Pre', route.options.pre, routePath)
            }
            if (route.options.handler) {
              wrapRouteHandler('Route', route.options, routePath)
              return
            }
          } else if (route.config) {
            if (route.config.pre) {
              route.config.pre = wrapPreRouteHandlers('Route.Pre', route.config.pre, routePath)
            }
            if (route.config.handler) {
              wrapRouteHandler('Route', route.config, routePath)
              return
            }
          }
          wrapRouteHandler('Route', route, routePath)
        }
      }
    })

    shimmer.wrap(serverPrototype, 'ext', function wrapExtensionHandler (original, name) {
      return function wrapppedExtensionHandler (event, method) {
        let args = Util.argsToArray.apply(this, arguments)

        if (Util.isArray(event)) {
          for (let i = 0; i < event.length; i++) {
            event[i].method = wrapExtensionMiddleware(event[i].method, event[i].type)
          }
        } else if (Util.isObject(event)) {
          event.method = wrapExtensionMiddleware(event.method, event.type)
        } else if (Util.isString(event)) {
          args[ARGS.FIRST] = wrapExtensionMiddleware(method, event)
        }

        return original.apply(this, args)
      }
    })

    function wrapRouteHandler (methodName, routeHandlerObject, routePath) {
      if (Util.isFunction(routeHandlerObject)) {
        return makeWrappedRouteHandler(methodName, routeHandlerObject, routePath)
      } else if (Util.getPropertyFromObject(routeHandlerObject, 'handler') && Util.isFunction(routeHandlerObject.handler)) {
        return shimmer.wrap(routeHandlerObject, 'handler', function wrapHandler (handler) {
          return makeWrappedRouteHandler(methodName, handler, routePath)
        })
      }
    }

    function makeWrappedRouteHandler (methodName, routeHandler, routePath) {
      return tracer.watchMiddleware(routeHandler,
        makeWatchMiddlewareOptions(methodName, routeHandler, routePath)
      )
    }

    function makeWatchMiddlewareOptions (methodName, routeHandler, routePath, isPreHandler) {
      return function watchMiddlewareOptionsCallback () {
        return {
          middlewareRequestObject: function makeMiddlewareRequestObject (original, methodName, args) {
            let request = !Util.isUndefined(args[ARGS.FIRST]) ? args[ARGS.FIRST] : null
            if (request && request.raw) {
              return request.raw.req
            }
          },
          framework: 'Hapi',
          middlewareName: Util.getObjectName(routeHandler),
          middlewareMethodName: 'Server.' + methodName,
          middlewareType: methodName === 'Route' ? TYPE.ROUTE : TYPE.MIDDLEWARE,
          middlewareCheckArity: false,
          middlewareIsPromise: true,
          routeName: routePath
        }
      }
    }

    function wrapPreRouteHandlers (methodName, container, path) {
      if (Util.isArray(container)) {
        for (let i = 0; i < container.length; ++i) {
          container[i] = wrapPreRouteHandlers(methodName, container[i], path)
        }
        return container
      } else if (Util.isFunction(container)) {
        return makeWrappedRouteHandler(methodName, container, path)
      } else if (Util.getPropertyFromObject(container, 'method') && Util.isFunction(container.method)) {
        return shimmer.wrap(container, 'method', function wrapHandler (handler) {
          return makeWrappedRouteHandler(methodName, handler, path)
        })
      }
      return container
    }

    function wrapExtensionMiddleware (middleware, event) {
      if (!ROUTE_EVENTS[event]) {
        return middleware
      }

      return tracer.watchMiddleware(middleware, function watchMiddlewareOptionsCallback () {
        return {
          middlewareRequestObject: function makeMiddlewareRequestObject (original, methodName, args) {
            let request = args[ARGS.FIRST]
            if (request && request.raw) {
              return request.raw.req
            }
          },
          framework: 'Hapi',
          middlewareName: Util.getObjectName(middleware),
          middlewareMethodName: 'Server.Ext.' + event,
          middlewareType: event === 'onPreResponse' ? TYPE.ERRORWARE : TYPE.MIDDLEWARE,
          middlewareCheckArity: false,
          middlewareIsPromise: true
        }
      })
    }
  }
}
