
'use strict'

const semver = require('semver')
const Util = require('../util')

const METHODS = [
  'all',
  'checkout',
  'copy',
  'delete',
  'get',
  'head',
  'lock',
  'merge',
  'mkactivity',
  'mkcol',
  'move',
  'm-search',
  'notify',
  'options',
  'patch',
  'post',
  'purge',
  'put',
  'report',
  'search',
  'subscribe',
  'trace',
  'unlock',
  'unsubscribe'
]
const ARGS = {
  FIRST: 0,
  SECOND: 1,
  THIRD: 2,
  LAST: -1
}

const TYPE = {
  APPLICATION: 'Application',
  ROUTE: 'Route',
  ROUTER: 'Router',
  MIDDLEWARE: 'Middleware',
  ERRORWARE: 'Errorware'
}
/**
 * Express Framework Instrumentation
 * Creates spans for each route a request flows through.
 * @param express
 * @param tracer
 * @param shimmer
 * @param version
 */
module.exports = function (express, tracer, shimmer, version) {
  if (semver.satisfies(version, '^4')) {
    wrapExpress4(express)
  } else if (semver.satisfies(version, '^3')) {
    wrapExpress3(express)
  }

  function wrapExpress3 (express) {
    tracer.setupMiddlewareMethod(express.Router.prototype, 'use',
      function setupOptionsCallback () {
        return {
          routeOptions: {
            routeArgPosition: ARGS.FIRST
          },
          middlewareOptions: {
            middlewareWrapper: wrapMiddleware
          }
        }
      }
    )

    tracer.setupMiddlewareMethod(express.application, 'use',
      function setupOptionsCallback () {
        return {
          routeOptions: {
            routeArgPosition: ARGS.FIRST
          },
          middlewareOptions: {
            middlewareWrapper: wrapMiddleware
          }
        }
      }
    )

    wrapRouteMethods(express.Router.prototype, ARGS.FIRST)
    if (semver.satisfies(version, '>= 3.0.0 <= 3.0.5')) {
      tracer.setupMiddlewareMethod(express.application, METHODS,
        function setupOptionsCallback () {
          return {
            routeOptions: {
              routeArgPosition: ARGS.FIRST
            },
            middlewareOptions: {
              middlewareWrapper: wrapMiddleware,
              middlewareWrapperOptions: {
                middlewareType: TYPE.ROUTE
              }
            }
          }
        }
      )
    }
  }
  function wrapExpress4 (express) {
    tracer.setupMiddlewareMethod(express.Router, 'use',
      function setupOptionsCallback () {
        return {
          routeOptions: {
            routeArgPosition: ARGS.FIRST
          },
          middlewareOptions: {
            middlewareWrapper: wrapMiddleware
          }
        }
      }
    )

    tracer.setupMiddlewareMethod(express.application, 'use',
      function setupOptionsCallback () {
        return {
          routeOptions: {
            routeArgPosition: ARGS.FIRST
          },
          middlewareOptions: {
            middlewareWrapper: wrapMiddleware
          }
        }
      }
    )

    shimmer.wrap(express.Router, 'route', function wrapRoute (original) {
      if (!Util.isFunction(original)) {
        return original
      }
      return function wrappedRoute () {
        var route = original.apply(this, arguments)
        // Express should create a new route and layer every time Router#route is
        // called, but just to be on the safe side, make sure we haven't wrapped
        // this already.
        if (!Util.isMonkeyPatched(route, 'get')) {
          let path = route.path || ''
          wrapRouteMethods(route, path)
          const layer = this.stack[this.stack.length - 1]
          tracer.watchMiddleware(layer, 'handle', function watchMiddlewareOptionsCallback () {
            return {
              framework: 'Express',
              middlewareName: 'handle',
              middlewareMethodName: 'Layer',
              middlewareType: TYPE.ROUTE,
              middlewareRequestObject: ARGS.FIRST,
              middlewareNextObject: ARGS.LAST,
              middlewareCheckArity: true,
              middlewareIsPromise: false,
              routeName: path
            }
          })
        }
        return route
      }
    })
  }

  function wrapRouteMethods (route, path) {
    if (semver.satisfies(version, '>3.0.5')) {
      tracer.setupMiddlewareMethod(route, METHODS,
        function setupOptionsCallback () {
          return {
            routeOptions: {
              routeArgPosition: path
            },
            middlewareOptions: {
              middlewareWrapper: wrapMiddleware,
              middlewareWrapperOptions: {
                middlewareType: TYPE.ROUTE
              }
            }
          }
        }
      )
    }
  }

  function wrapMiddleware (middlewareHandler, middlewareHandlerName, routeName, methodName, middlewareWrapperOptions) {
    let framework = 'Express'
    let middlewareName = middlewareHandlerName
    let middlewareMethodName = methodName
    let middlewareType = TYPE.MIDDLEWARE
    let middlewareRequestObject = ARGS.FIRST
    let middlewareNextObject = ARGS.LAST
    let middlewareCheckArity = true
    let middlewareIsPromise = false
    let middlewareHandlerMethod = null

    if (!middlewareHandler) {
      return middlewareHandler
    }

    if (typeof middlewareHandler['lazyrouter'] !== 'undefined') {
      middlewareHandlerMethod = 'handle'
      middlewareType = TYPE.APPLICATION
    } else if (typeof middlewareHandler['stack'] !== 'undefined') {
      middlewareHandlerMethod = 'handle'
      middlewareType = TYPE.ROUTER
    } else if (middlewareHandler.length === 4) {
      middlewareType = TYPE.ERRORWARE
      middlewareRequestObject = ARGS.SECOND
      middlewareNextObject = ARGS.LAST
    }

    let finalMiddlewareWrapperOptions = {
      framework: framework,
      middlewareName: middlewareName,
      middlewareMethodName: middlewareMethodName,
      middlewareType: middlewareType,
      middlewareRequestObject: middlewareRequestObject,
      middlewareNextObject: middlewareNextObject,
      middlewareCheckArity: middlewareCheckArity,
      middlewareIsPromise: middlewareIsPromise,
      routeName: routeName
    }
    // We dont have to deal with the middleware with mounted app name as it is a sub application
    if (Util.isMonkeyPatched(middlewareHandler, middlewareHandlerMethod) || middlewareName === 'mounted_app') {
      return middlewareHandler
    }

    if (middlewareWrapperOptions && Util.isObject(middlewareWrapperOptions)) {
      finalMiddlewareWrapperOptions = Object.assign(finalMiddlewareWrapperOptions, middlewareWrapperOptions)
    }

    let wrapped = tracer.watchMiddleware(
      middlewareHandler,
      middlewareHandlerMethod,
      function watchMiddlewareOptionsCallback () {
        return finalMiddlewareWrapperOptions
      }, {
        checkArity: middlewareCheckArity
      })

    return wrapped
  }
}
