'use strict'

const Logger = require('./../../logger')

/**
 * Instrumentation for global module (currently a placeholder).
 * @param globalModule
 * @param tracer
 * @param shimmer
 * @param packageVersion
 */
module.exports = function (globalModule, tracer, shimmer, packageVersion) {
  Logger.debug('load global module patching')

  // Fatal exception reference
  // - https://github.com/nodejs/node/blob/5877836a33c23dfa591f75005182fb4ab379bcdc/lib/internal/bootstrap/node.js
  // - https://github.com/nodejs/node/blob/1a2cf6696fa59c9723c423c4ff4c1167ab82155c/lib/domain.js
  // `_fatalException` is an undocumented feature of domains, introduced in
  // Node.js v0.8. We use `_fatalException` because wrapping it will not
  // potentially change the behavior of the server unlike listening for
  // `uncaughtException`.
  shimmer.wrap(process, '_fatalException', function wrapFatalException (original) {
    return function wrappedFatalException (error) {
      if (tracer) {
        Logger.debug('Hook:process._fatalException - Uncaught exception raised - Error: %s', error.message)
        Logger.debug('Hook:process._fatalException - Flushing queue')
        tracer.addErrorToActiveTransaction(error)
        tracer.forceFlushQueue()
      }
      return original.apply(this, arguments)
    }
  })

  /**
   * Instrument process emit function in order to track unhandled promise rejections
   * and add it to the current tranasction or the transaction being passed
   */
  shimmer.wrap(process, 'emit', function wrapEmit (original) {
    return function wrappedEmit (ev, error, promise) {
      if (ev === 'unhandledRejection' && error) {
        if (process.listenerCount('unhandledRejection') === 0) {
          const transaction = promise.stackifySpanInContext
            ? promise.stackifySpanInContext.getTransaction()
            : undefined
          Logger.debug('Hook:process.emit - Captured unhandled rejection for transaction %s', transaction && transaction.id())
          tracer.addErrorToActiveTransaction(error, transaction)
        }
      }
      return original.apply(this, arguments)
    }
  })

  const promiseOptions = {
    classConstructor: 'Promise',
    classPrototypeOptions: {
      resolveMethods: ['then', 'chain'],
      rejectMethods: ['catch']
    },
    classStaticOptions: {
      copyMethods: ['accept', 'all', 'defer', 'race', 'reject', 'resolve'],
      castMethods: ['accept', 'all', 'defer', 'race', 'reject', 'resolve']
    }
  }

  require('../promise')(global, tracer, shimmer, promiseOptions)
}
