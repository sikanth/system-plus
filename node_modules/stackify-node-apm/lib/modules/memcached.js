'use strict'

/**
 * Memcached Instrumentation
 * https://www.npmjs.com/package/memcached
 * @param Memcached
 * @param tracer
 * @param shimmer
 * @param version
 */
module.exports = function (Memcached, tracer, shimmer, version) {
  const METHODS = [
    'touch',
    'get',
    'gets',
    'getMulti',
    'set',
    'replace',
    'add',
    'cas',
    'append',
    'prepend',
    'incr',
    'decr',
    'del',
    'flush',
    'stats',
    'settings',
    'slabs',
    'items'
  ]

  METHODS.forEach(method => {
    shimmer.wrap(Memcached.prototype, method, createWrapMethod(method))
  })

  /**
   * Create wrapping function for passed in memcached method
   * @param method
   */
  function createWrapMethod (method) {
    return wrapMethod

    /**
     *
     * @param original
     * @return {function(): *}
     */
    function wrapMethod (original) {
      return function () {
        const span = tracer.createSpan('Memcached.' + method)

        if (span) {
          span.addProperty('CATEGORY', 'Cache')
          span.addProperty('SUBCATEGORY', 'Execute')
          span.addProperty('COMPONENT_CATEGORY', 'Cache')
          span.addProperty('COMPONENT_DETAIL', 'Execute')
          if (this.servers) span.addProperty('URL', this.servers.toString())

          let key = arguments[0]
          if (key && typeof key === 'string') {
            span.addProperty('CACHEKEY', key)
          }

          let index = arguments.length - 1
          let cb = arguments[index]
          if (cb && typeof cb === 'function') {
            arguments[index] = wrapCallback(cb)
          }
        }

        return original.apply(this, arguments)

        function wrapCallback (cb) {
          return function () {
            if (span) {
              tracer.endSpan(span)
            }
            return cb.apply(this, arguments)
          }
        }
      }
    }
  }

  return Memcached
}
