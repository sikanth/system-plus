'use strict'

const Util = require('../util')
const URL = require('url')
const stringify = require('json-stringify-safe')

/**
 * Wraps http/https remote call
 * @param tracer
 * @param call
 */
module.exports.wrapRemoteRequestCall = function (tracer, call) {
  return function wrapRemoteRequestCall (original) {
    return function wrappedRemoteRequestCall () {
      let args = Util.argsToArray.apply(this, arguments)
      let currentCall = call

      if (Util.isFunction(args[1])) {
        if (typeof args[1].fromGet !== 'undefined') {
          currentCall = args[1].fromGet.slice(0)
          delete args[1].fromGet
        }
      }

      let span = tracer.createSpan(currentCall)
      if (Util.isFunction(args[1]) && span) {
        args[1] = tracer.bindSpanCallback(args[1], span, call + ' - Callback')
      }

      let req = tracer.bindSpanCallback(function boundRequest () {
        let req = original.apply(this, args)
        if (span) {
          tracer.bindEmitter(req)

          let protocol = call.split('.')[0]
          let host = req._headers.host

          let path = Util.removeQueryString(req.path)
          let url = URL.parse(protocol + '://' + host + '' + path)

          span.addProperty('URL', Util.removeTrailingSlash(url.href))
          span.addProperty('METHOD', req.method)
          span.addProperty('CATEGORY', 'Web External')
          span.addProperty('SUBCATEGORY', 'Execute')
          span.addProperty('COMPONENT_CATEGORY', 'Web External')
          span.addProperty('COMPONENT_DETAIL', 'Execute')
          req.on('response', onResponse)
        }

        if (span && span.getTransaction().getConfiguration().prefixEnabled) {
          setRequestDetailProps(span, req)
        }

        return req
      }, span, call).apply(this, args)

      return req

      function onResponse (response) {
        if (span) {
          tracer.bindEmitter(response)
          span.addProperty('STATUS', response.statusCode)
          if (span && span.getTransaction().getConfiguration().prefixEnabled) {
            setResponseDetailProps(span, response)
          }
        }

        // Inspired by:
        // https://github.com/nodejs/node/blob/9623ce572a02632b7596452e079bba066db3a429/lib/events.js#L258-L274
        if (response.prependListener) {
          // Added in Node.js 6.0.0
          response.prependListener('end', onEnd)
        } else {
          var existing = response._events && response._events.end
          if (!existing) {
            response.on('end', onEnd)
          } else {
            if (typeof existing === 'function') {
              response._events.end = [onEnd, existing]
            } else {
              existing.unshift(onEnd)
            }
          }
        }

        function onEnd () {
          if (span) {
            tracer.endSpan(span)
          }
        }
      }

      /**
       * Get the Response header/body details
       * @param {Object} span
       * @param {Object} response
       */
      function setResponseDetailProps (span, response) {
        let responseBody = ''
        response.on('data', function (chunk) {
          responseBody += chunk.toString()
          let responseBytes = Buffer.byteLength(responseBody, 'utf8')
          span.addProperty('PREFIX_RESPONSE_BODY', responseBody.toString().replace(/%/g, '%%').toString())
          span.addProperty('PREFIX_RESPONSE_SIZE_BYTES', responseBytes.toString())
        })

        let resHeadersAry = []
        let resHeadersObj = response.headers
        for (let key in resHeadersObj) {
          if (resHeadersObj.hasOwnProperty(key)) {
            Util.pushToAry(resHeadersAry, key.toString(), resHeadersObj[key].toString().replace(/%/g, '%%').toString())
          }
        }
        span.addProperty('PREFIX_RESPONSE_HEADERS', stringify(resHeadersAry))
      }

      /**
       * Get the Request header/body details
       * @param {Object} span
       * @param {Object} req
       */
      function setRequestDetailProps (span, req) {
        req.on('socket', function (socket) {
          let p = socket._pendingData
          let n = p.length
          if (n > 0) {
            let headerString = p[0]['chunk'] || ''
            let rawHeader = headerString.split('\r\n')
            let nitem = rawHeader.length
            let requestbody = rawHeader[nitem - 1]
            let requestBytes = Buffer.byteLength(requestbody, 'utf8')
            span.addProperty('PREFIX_REQUEST_BODY', requestbody.toString().replace(/%/g, '%%').toString())
            span.addProperty('PREFIX_REQUEST_SIZE_BYTES', requestBytes.toString())
            let reqHeadersAry = []
            let reqHeadersObj = req._headers
            for (let key in reqHeadersObj) {
              if (reqHeadersObj[key]) {
                Util.pushToAry(reqHeadersAry, key.toString(), reqHeadersObj[key].toString().replace(/%/g, '%%').toString())
              }
            }
            span.addProperty('PREFIX_REQUEST_HEADERS', stringify(reqHeadersAry))
          }
        })
      }
    }
  }
}
