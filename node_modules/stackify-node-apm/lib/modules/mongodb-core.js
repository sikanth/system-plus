'use strict'

const semver = require('semver')
const SERVER_FNS = ['insert', 'update', 'remove', 'auth']
const CURSOR_FNS_FIRST = ['_find', '_getmore']

/**
 * mongodb-core instrumentation
 * https://www.npmjs.com/package/mongodb-core
 * @param mongodb
 * @param tracer
 * @param shimmer
 * @param version
 */
module.exports = function (mongodb, tracer, shimmer, version) {
  if (!semver.satisfies(version, '>=1.2.19 <4.0.0')) {
    return mongodb
  }

  if (mongodb.Server) {
    shimmer.wrap(mongodb.Server.prototype, 'command', wrapCommand)
    shimmer.massWrap(mongodb.Server.prototype, SERVER_FNS, wrapQuery)
  }

  if (mongodb.Cursor) {
    shimmer.massWrap(mongodb.Cursor.prototype, CURSOR_FNS_FIRST, wrapCursor)
  }

  return mongodb

  /**
   * Wraps command calls
   * @param orig
   */
  function wrapCommand (orig) {
    return function wrappedFunction (ns, cmd) {
      let span
      if (tracer.getActiveTransaction() && arguments.length > 0) {
        let index = arguments.length - 1
        let cb = arguments[index]
        if (typeof cb === 'function') {
          let type
          if (cmd.findAndModify) type = 'findAndModify'
          else if (cmd.createIndexes) type = 'createIndexes'
          else if (cmd.ismaster) type = 'ismaster'
          else if (cmd.count) type = 'count'
          else type = 'command'

          span = tracer.createSpan('mongodb.' + type)
          if (span) {
            span.addProperty('CATEGORY', 'MongoDB')
            span.addProperty('MONGODB_COLLECTION', this.ns)
          }
          arguments[index] = wrappedCallback(cb, span)
        }
      }

      return orig.apply(this, arguments)

      function wrappedCallback (cb, span) {
        return tracer.bindSpanCallback(function () {
          if (span) {
            tracer.endSpan(span)
          }
          return cb.apply(this, arguments)
        }, span)
      }
    }
  }

  /**
   * Wraps query calls
   * @param orig
   * @param name
   */
  function wrapQuery (orig, name) {
    return function wrappedFunction (ns) {
      let span
      if (tracer.getActiveTransaction() && arguments.length > 0) {
        let index = arguments.length - 1
        let cb = arguments[index]
        if (typeof cb === 'function') {
          span = tracer.createSpan('mongodb.query')

          if (span) {
            span.addProperty('CATEGORY', 'MongoDB')
            span.addProperty('MONGODB_COLLECTION', ns)
          }

          arguments[index] = wrappedCallback(cb, span)
        }
      }

      return orig.apply(this, arguments)

      function wrappedCallback (cb, span) {
        return tracer.bindSpanCallback(function () {
          if (span) {
            tracer.endSpan(span)
          }
          return cb.apply(this, arguments)
        }, span)
      }
    }
  }

  /**
   * Wraps cursor calls
   * @param orig
   * @param name
   */
  function wrapCursor (orig, name) {
    return function wrappedFunction () {
      let span
      if (tracer.getActiveTransaction() && arguments.length > 0) {
        let cb = arguments[0]
        if (typeof cb === 'function') {
          let type = this.cmd.find ? 'find' : name
          span = tracer.createSpan('mongodb.' + type)
          if (span) {
            span.addProperty('CATEGORY', 'MongoDB')
            span.addProperty('MONGODB_COLLECTION', this.ns)
          }
          arguments[0] = wrappedCallback(cb, span)
        }
      }

      return orig.apply(this, arguments)

      function wrappedCallback (cb, span) {
        return tracer.bindSpanCallback(function () {
          let result = cb.apply(this, arguments)
          if (span) {
            tracer.endSpan(span)
          }
          return result
        }, span)
      }
    }
  }
}
