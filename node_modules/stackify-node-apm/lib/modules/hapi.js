'use strict'

const Util = require('../util')

const ARGS = {
  FIRST: 0,
  SECOND: 1,
  THIRD: 2,
  LAST: -1
}

const TYPE = {
  APPLICATION: 'Application',
  ROUTE: 'Route',
  ROUTER: 'Router',
  MIDDLEWARE: 'Middleware',
  ERRORWARE: 'Errorware'
}

const ROUTE_EVENTS = {
  onRequest: true,
  onPreAuth: true,
  onCredentials: true,
  onPostAuth: true,
  onPreHandler: true,
  onPostHandler: true,
  onPreResponse: true,

  // Server events
  onPreStart: false,
  onPostStart: false,
  onPreStop: false,
  onPostStop: false
}

/**
 * Hapi Instrumentation
 * https://www.npmjs.com/package/hapi
 * @param Hapi
 * @param tracer
 * @param shimmer
 * @param version
 */
module.exports = function (hapi, tracer, shimmer, version) {
  if (hapi.Server) {
    if (!hapi.Server.prototype.connection) {
      return require('./hapi/hapi-17')(hapi, tracer, shimmer, version)
    }

    let Plugin = hapi.Server.super_
    if (isPluginClass(Plugin)) {
      wrapServerClass(Plugin)
    } else {
      wrapServerClass(hapi.Server)
    }
  }

  function wrapServerClass (Server) {
    shimmer.wrap(Server.prototype, 'handler', function wrapHandler (original, name) {
      return function wrappedHandler () {
        let args = Util.argsToArray.apply(this, arguments)
        let handlerGeneratorIndex = 1
        let handlerGenerator = typeof args[handlerGeneratorIndex] !== 'undefined' ? args[1] : null

        if (Util.isFunction(handlerGenerator)) {
          shimmer.wrap(args, handlerGeneratorIndex, function wrapRouteHandlerGenerator (original) {
            if (Util.getPropertyFromObject(original, 'defaults')) {
              wrappedRouteHandlerGenerator.defaults = original.defaults
            }

            return wrappedRouteHandlerGenerator

            function wrappedRouteHandlerGenerator () {
              let routeHandlerGeneratorArgs = Util.argsToArray.apply(this, arguments)
              let routeHandler = original.apply(this, routeHandlerGeneratorArgs)

              if (Util.isFunction(routeHandler)) {
                let route = !Util.isUndefined(routeHandlerGeneratorArgs[0]) ? routeHandlerGeneratorArgs[0] : null
                return wrapRouteHandler('Handler', routeHandler, route && route.path)
              }

              return routeHandler
            }
          })
        }

        return original.apply(this, args)
      }
    })

    shimmer.wrap(Server.prototype, 'route', function wrapRoute (original, name) {
      return function wrappedRoute () {
        let args = Util.argsToArray.apply(this, arguments)

        if (!Util.isObject(args[ARGS.FIRST])) {
          return original.apply(this, args)
        }

        // If route is created via a plugin, pull prefix if it exists
        const pluginPrefix = (
          this.realm &&
          this.realm.modifiers &&
          this.realm.modifiers.route &&
          this.realm.modifiers.route.prefix
        ) || ''

        makeWrappedRoute(args[ARGS.FIRST], pluginPrefix)

        return original.apply(this, args)

        function makeWrappedRoute (route, pluginPrefix) {
          const routePath = pluginPrefix + route.path
          // handler function could be on the route object, or on a nested config object
          if (Util.isArray(route)) {
            for (let i = 0; i < route.length; ++i) {
              makeWrappedRoute(route[i], pluginPrefix)
            }
            return
          } else if (route.config) {
            if (route.config.pre) {
              // config objects can also contain multiple OTHER handlers in a `pre` array
              route.config.pre = wrapPreRouteHandlers('Route.Pre', route.config.pre, routePath)
            }
            if (route.config.handler) {
              wrapRouteHandler('Route', route.config, routePath)
              return
            }
          }
          wrapRouteHandler('Route', route, routePath)
        }
      }
    })

    shimmer.wrap(Server.prototype, 'ext', function wrapExtensionHandler (original, name) {
      return function wrapppedExtensionHandler (event, method) {
        let args = Util.argsToArray.apply(this, arguments)

        if (Util.isArray(event)) {
          for (let i = 0; i < event.length; i++) {
            event[i].method = wrapExtensionMiddleware(event[i].method, event[i].type)
          }
        } else if (Util.isObject(event)) {
          event.method = wrapExtensionMiddleware(event.method, event.type)
        } else if (Util.isString(event)) {
          args[ARGS.FIRST] = wrapExtensionMiddleware(method, event)
        }

        return original.apply(this, args)
      }
    })

    function wrapRouteHandler (methodName, routeHandlerObject, routePath) {
      if (Util.isFunction(routeHandlerObject)) {
        return makeWrappedRouteHandler(methodName, routeHandlerObject, routePath)
      } else if (routeHandlerObject.handler && Util.isFunction(routeHandlerObject.handler)) {
        return shimmer.wrap(routeHandlerObject, 'handler', function wrapHandler (handler) {
          return makeWrappedRouteHandler(methodName, handler, routePath)
        })
      }
    }

    function makeWrappedRouteHandler (methodName, routeHandler, routePath) {
      return tracer.watchMiddleware(routeHandler,
        makeWatchMiddlewareOptions(methodName, routeHandler, routePath)
      )
    }

    function makeWatchMiddlewareOptions (methodName, routeHandler, routePath, isPreHandler) {
      return function watchMiddlewareOptionsCallback () {
        return {
          middlewareRequestObject: function makeMiddlewareRequestObject (original, methodName, args) {
            let request = !Util.isUndefined(args[ARGS.FIRST]) ? args[ARGS.FIRST] : null
            if (request && request.raw) {
              return request.raw.req
            }
          },
          middlewareNextObject: function makeMiddlewareNextObject (original, methodName, args, activeSpan, bindNextWrapper) {
            let reply = !Util.isUndefined(args[ARGS.SECOND]) ? args[ARGS.SECOND] : null
            if (!Util.isFunction(reply)) {
              return
            }

            wrapReplyObject(bindNextWrapper, reply, isPreHandler)
          },
          framework: 'Hapi',
          middlewareName: Util.getObjectName(routeHandler),
          middlewareMethodName: 'Server.' + methodName,
          middlewareType: methodName === 'Route' ? TYPE.ROUTE : TYPE.MIDDLEWARE,
          middlewareCheckArity: false,
          middlewareIsPromise: false,
          routeName: routePath
        }
      }
    }

    function wrapPreRouteHandlers (methodName, container, path) {
      if (Util.isArray(container)) {
        for (let i = 0; i < container.length; ++i) {
          container[i] = wrapPreRouteHandlers(methodName, container[i], path)
        }
        return container
      } else if (Util.isFunction(container)) {
        return makeWrappedRouteHandler(methodName, container, path)
      } else if (Util.getPropertyFromObject(container, 'method') && Util.isFunction(container.method)) {
        return shimmer.wrap(container, 'method', function wrapHandler (handler) {
          return makeWrappedRouteHandler(methodName, handler, path)
        })
      }
      return container
    }

    function wrapExtensionMiddleware (middleware, event) {
      if (!ROUTE_EVENTS[event]) {
        return middleware
      }

      return tracer.watchMiddleware(middleware, function watchMiddlewareOptionsCallback () {
        return {
          middlewareNextObject: function makeMiddlewareNextObject (original, methodName, args, activeSpan, bindNextWrapper) {
            let reply = args[ARGS.SECOND]
            if (!reply || !Util.isFunction(reply.continue)) return

            bindNextWrapper(reply, 'continue')
          },
          middlewareRequestObject: function makeMiddlewareRequestObject (original, methodName, args) {
            let request = args[ARGS.FIRST]
            if (request && request.raw) {
              return request.raw.req
            }
          },
          framework: 'Hapi',
          middlewareName: Util.getObjectName(middleware),
          middlewareMethodName: 'Server.Ext.' + event,
          middlewareType: event === 'onPreResponse' ? TYPE.ERRORWARE : TYPE.MIDDLEWARE,
          middlewareCheckArity: false,
          middlewareIsPromise: false
        }
      })
    }

    function wrapReplyObject (bindNextWrapper, reply, isPreHandler) {
      let isFinal = !isPreHandler
      bindNextWrapper(reply, 'continue', isFinal)
      bindNextWrapper(reply, 'redirect', isFinal)
      bindNextWrapper(reply, 'close', isFinal)
      bindNextWrapper(reply, 'response', isFinal)
    }
  }

  function isPluginClass (Plugin) {
    if (typeof Plugin !== 'function' || !Plugin.prototype) {
      return false
    }

    let proto = Plugin.prototype
    return (
      Util.isFunction(proto.handler) &&
      Util.isFunction(proto.route) &&
      Util.isFunction(proto.ext)
    )
  }
}
