'use strict'

const Logger = require('../logger')
const semver = require('semver')
const Util = require('./../util')
const stringify = require('json-stringify-safe')

/**
 * Postgres module instrumentation
 * @param pg
 * @param tracer
 * @param shimmer
 * @param version
 */
module.exports = function (pg, tracer, shimmer, version) {
  if (!semver.satisfies(version, '>=4.0.0 <8.0.0')) {
    Logger.debug('pg version %s not supported', version)
    return pg
  }

  patchClient(pg.Client, 'pg.Client')

  return pg

  function patchClient (Client, call) {
    shimmer.wrap(Client.prototype, 'connect', wrapConnect)
    shimmer.wrap(Client.prototype, 'query', wrapQuery)

    /**
     * Wraps postgres connection call
     * @param original
     */
    function wrapConnect (original) {
      return function wrappedConnect () {
        let args = Util.argsToArray.apply(this, arguments)
        let callbackIndex = args.length - 1
        let hasCallback = false
        const span = tracer.createSpan(call + '.connect')
        if (span) {
          let host, port
          if (typeof this.connectionParameters === 'object') {
            ({ host, port } = this.connectionParameters)
          }

          span.addProperty('CATEGORY', 'Database')
          span.addProperty('SUBCATEGORY', 'Open')
          span.addProperty('PROVIDER', 'postgres')
          span.addProperty('COMPONENT_CATEGORY', 'Database')
          span.addProperty('COMPONENT_DETAIL', 'Open Connection')
          span.addProperty('URL', host + ':' + port)

          if (Util.isFunction(args[callbackIndex]) && !Util.isMonkeyPatched(args[callbackIndex])) {
            let wrappedCallback = shimmer.wrap(args[callbackIndex], null, function wrapCallback (original) {
              return function wrappedCallback () {
                if (span) {
                  tracer.endSpan(span)
                }
                return tracer.bindSpanCallback(original, span).apply(this, arguments)
              }
            })
            if (typeof wrappedCallback !== 'undefined') {
              args[callbackIndex] = wrappedCallback
              hasCallback = true
            } else {
              Logger.error('Postgres:Connect - wrapConnect - Unable to wrap callback, something went wrong')
            }
          }
        }
        if (!hasCallback && semver.satisfies(version, '< 7.0.0')) {
          let noopCallback = shimmer.wrap(function noop () {}, null, function wrapConnect (original) {
            return tracer.bindSpanCallback(function wrappedCallback () {
              if (span) {
                tracer.endSpan(span)
              }
              return original.apply(this, arguments)
            }, span)
          })
          args.unshift(noopCallback)
        }
        let result = tracer.bindSpanCallback(original, span).apply(this, args)
        if (!hasCallback && Util.isPromise(result)) {
          result.then(function onFulfilled (value) {
            tracer.endSpan(span)
            return value
          }, function onRejected (err) {
            tracer.endSpan(span)
            throw err
          })
        }
        return result
      }
    }

    /**
     * Wraps postgres query call
     * @param original
     */
    function wrapQuery (original) {
      return function (sql) {
        let args = Util.argsToArray.apply(this, arguments)
        let sqlStr = null
        let isPreparedStatement = false
        const span = tracer.createSpan(call + '.query')

        if (span) {
          let host, port
          if (typeof this.connectionParameters === 'object') {
            ({ host, port } = this.connectionParameters)
          }

          span.addProperty('CATEGORY', 'Database')
          span.addProperty('SUBCATEGORY', 'Execute')
          span.addProperty('PROVIDER', 'postgres')
          span.addProperty('COMPONENT_CATEGORY', 'DB Query')
          span.addProperty('COMPONENT_DETAIL', 'Execute SQL Query')
          span.addProperty('URL', host + ':' + port)

          if (sql && typeof sql.text === 'string') {
            sqlStr = sql.text
            sqlStr = Util.truncateSQL(sqlStr, span)
            span.addProperty('SQL', sqlStr)
          } else if (sql && typeof sql === 'string') {
            sqlStr = sql
            sqlStr = Util.truncateSQL(sqlStr, span)
            span.addProperty('SQL', sqlStr)
          }

          if (sqlStr && sqlStr.match(/\$\d/)) isPreparedStatement = true
          if (tracer.getConfiguration().prefixEnabled && isPreparedStatement) {
            let prepValues = (args && args[0] && args[0].values) ? args[0].values : []
            let sqlParam = []
            prepValues.forEach(function (val, idx) {
              Util.pushToAryIndex(sqlParam, idx, val.toString().substring(0, 1000))
            })
            span.addProperty('PREFIX_SQL_PARAMETERS', stringify(sqlParam.slice(0, 100)))
            span.addProperty('PREFIX_SQL_PARAMETER_COUNT', sqlParam.length.toString())
          }
          let index = args.length - 1
          let cb = args[index]

          if (Array.isArray(cb)) {
            index = cb.length - 1
            if (Util.isFunction(cb[index]) && !Util.isMonkeyPatched(cb)) {
              cb[index] = wrapCallback(cb, index)
            }
          } else if (cb && typeof cb === 'function' && !Util.isMonkeyPatched(cb)) {
            args[index] = wrapCallback(args, index)
          }
        }
        let result = tracer.bindSpanCallback(original, span).apply(this, args)
        if (semver.satisfies(pg._version, '>=6.3.0 < 7.0.0')) {
          if (span && result && result._getPromise && !Util.isMonkeyPatched(result._getPromise)) {
            shimmer.wrap(result, '_getPromise', function wrapGetPromise (original) {
              return function wrappedGetPromise () {
                let resultPromise = original.apply(this, arguments)
                // Override span in context to the current span
                if (resultPromise && Util.isPromise(resultPromise)) {
                  resultPromise.stackifySpanInContext = span
                }
                return resultPromise
              }
            })
          }
        }
        if (semver.satisfies(pg._version, '>=5.1.0 < 6.3.0')) {
          if (span && result && !result._getPromise && result.promise && !Util.isMonkeyPatched(result.promise)) {
            shimmer.wrap(result, 'promise', function wrapGetPromise (original) {
              return function wrappedGetPromise () {
                let resultPromise = original.apply(this, arguments)
                // Override span in context to the current span
                if (resultPromise && Util.isPromise(resultPromise)) {
                  resultPromise.stackifySpanInContext = span
                }
                return resultPromise
              }
            })
          }
        }
        return result

        function wrapCallback (args, index) {
          let wrappedCallback = shimmer.wrap(args, index, function wrapCallback (original) {
            return function wrappedCallback () {
              if (span) {
                tracer.endSpan(span)
              }
              return tracer.bindSpanCallback(original, span).apply(this, arguments)
            }
          })
          return wrappedCallback
        }
      }
    }
  }
}
