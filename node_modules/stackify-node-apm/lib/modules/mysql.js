'use strict'

const Logger = require('../logger')
const semver = require('semver')
const Util = require('./../util')
const stringify = require('json-stringify-safe')

/**
 * MySQL module instrumentation
 * @param mysql
 * @param tracer
 * @param shimmer
 * @param version
 */
module.exports = function (mysql, tracer, shimmer, version) {
  if (!semver.satisfies(version, '^2.0.0')) {
    Logger.debug('mysql version %s not supported', version)
    return mysql
  }

  shimmer.wrap(mysql, 'createConnection', wrapCreateConnection)
  shimmer.wrap(mysql, 'createPool', wrapCreatePool)
  shimmer.wrap(mysql, 'createPoolCluster', wrapCreatePoolCluster)

  return mysql

  /**
   * Wraps mysql.createPool
   * @param original
   */
  function wrapCreatePool (original) {
    return function wrappedCreatePool () {
      let pool = original.apply(this, arguments)
      // shimming mysql cluster pool.
      if (typeof pool.getConnection !== 'undefined' &&
        Util.isFunction(pool.getConnection) &&
        !Util.isMonkeyPatched(pool.getConnection)
      ) {
        shimmer.wrap(pool, 'getConnection', makeWrapGetConnection('Pool'))
      }
      return pool
    }
  }

  /**
   * Wraps mysql.createPoolCluster
   * @param original
   */
  function wrapCreatePoolCluster (original) {
    return function wrappedCreatePoolCluster () {
      let cluster = original.apply(this, arguments)

      // shimming mysql cluster.of
      if (typeof cluster.of !== 'undefined' &&
        Util.isFunction(cluster.of) &&
        !Util.isMonkeyPatched(cluster.of)
      ) {
        shimmer.wrap(cluster, 'of', wrapOf)
      }

      return cluster

      function wrapOf (original) {
        return function wrappedOf () {
          let ofCluster = original.apply(this, arguments)
          // shimming mysql cluster of.getConnection
          if (typeof ofCluster.getConnection !== 'undefined' &&
            Util.isFunction(ofCluster.getConnection) &&
            !Util.isMonkeyPatched(ofCluster.getConnection)
          ) {
            shimmer.wrap(ofCluster, 'getConnection', makeWrapGetConnection('PoolCluster.of'))
          }
          return ofCluster
        }
      }
    }
  }
  /**
   * Wraps mysql getConnection
   * @param original
   */
  function makeWrapGetConnection (call) {
    return function wrapGetConnection (original) {
      return function wrappedGetConnection () {
        let args = Util.argsToArray.apply(this, arguments)
        let callbackIndex = 0
        let callback = args[callbackIndex]

        if (Util.isFunction(callback) && !Util.isMonkeyPatched(callback)) {
          args[callbackIndex] = wrapCallback(function wrappedCallback () {
            let args = Util.argsToArray.apply(this, arguments)
            let connectionIndex = args.length - 1
            let connectionCallback = args[connectionIndex]
            if (connectionCallback) {
              wrapQueryable(connectionCallback, call + '.getConnection.connection')
            }
            return callback.apply(this, args)
          })
        }
        return original.apply(this, args)
      }
    }
  }

  /**
   * Wraps mysql.createConnection
   * @param original
   */
  function wrapCreateConnection (original) {
    return function wrappedCreateConnection () {
      let connection = original.apply(this, arguments)
      wrapQueryable(connection, 'connection')
      wrapConnectable(connection, 'connection')
      return connection
    }
  }

  /**
   * Wraps query function on passed in obj
   * @param obj
   * @param objType
   */
  function wrapQueryable (obj, objType) {
    shimmer.wrap(obj, 'query', wrapQuery)

    let host, port
    if (typeof obj.config === 'object') {
      ({ host, port } = obj.config)
    }

    function wrapQuery (original) {
      return function wrappedQuery (sql, values, cb) {
        let args = Util.argsToArray.apply(this, arguments)
        let call = 'mysql.' + objType + '.query'
        let hasCallback = false
        let sqlStr
        let isPreparedStatement = false
        const span = tracer.createSpan(call)

        if (span) {
          switch (typeof sql) {
            case 'string':
              sqlStr = sql
              break
            case 'object':
              if (Util.isFunction(sql._callback) && !Util.isMonkeyPatched(sql._callback)) {
                sql._callback = wrapQueryCallback(sql._callback, span)
              }
              sqlStr = sql.sql
              break
            case 'function':
              if (!Util.isMonkeyPatched(sql)) {
                args[0] = wrapQueryCallback(sql, span)
              }
              break
          }
          span.addProperty('CATEGORY', 'Database')
          span.addProperty('SUBCATEGORY', 'Execute')
          span.addProperty('PROVIDER', 'mysql')
          span.addProperty('COMPONENT_CATEGORY', 'DB Query')
          span.addProperty('COMPONENT_DETAIL', 'Execute SQL Query')
          span.addProperty('THREAD_ID', this.threadId)
          if (host && port) span.addProperty('URL', host + ':' + port)

          if (sqlStr) {
            sqlStr = Util.truncateSQL(sqlStr, span)
            span.addProperty('SQL', sqlStr)
            if (sqlStr.indexOf('?') > -1) isPreparedStatement = true
          }

          if (tracer.getConfiguration().prefixEnabled && isPreparedStatement) {
            let prepValues = (args && args[1]) ? args[1] : []
            let sqlParam = []
            prepValues.forEach(function (val, idx) {
              Util.pushToAryIndex(sqlParam, idx, val.toString().substring(0, 1000))
            })
            span.addProperty('PREFIX_SQL_PARAMETERS', stringify(sqlParam.slice(0, 100)))
            span.addProperty('PREFIX_SQL_PARAMETER_COUNT', sqlParam.length.toString())
          }

          if (Util.isFunction(values) && !Util.isMonkeyPatched(values)) {
            args[1] = wrapQueryCallback(values, span)
          } else if (Util.isFunction(cb) && !Util.isMonkeyPatched(cb)) {
            args[2] = wrapQueryCallback(cb, span)
          }
        }

        // SqlResult
        const result = original.apply(this, args)

        // if we have no callback, try to patch the emit function
        if (span && result && !hasCallback && typeof result.emit !== 'undefined' && Util.isFunction(result.emit)) {
          shimmer.wrap(result, 'emit', function (original) {
            return function (event) {
              switch (event) {
                case 'error':
                case 'end':
                  tracer.endSpan(span)
              }
              // Bind the emit function with the current span
              return tracer.bindSpanCallback(original, span).apply(this, arguments)
            }
          })
        }

        return result

        function wrapQueryCallback (cb, span) {
          return wrapCallback(cb, span, function preHook () {
            hasCallback = true
          })
        }
      }
    }
  }

  /**
   * Wraps connection function on passed in obj
   * @param obj
   * @param objType
   */
  function wrapConnectable (obj, objType) {
    Logger.info('[instrumentation/mysql] wrapQueryable() shimming mysql %s.query', objType)
    shimmer.wrap(obj, 'connect', wrapConnect)

    let host, port
    if (typeof obj.config === 'object') {
      ({ host, port } = obj.config)
    }

    function wrapConnect (original) {
      return function wrappedConnect () {
        let args = Util.argsToArray.apply(this, arguments)
        let callbackIndex = 0
        let call = 'mysql.' + objType + '.connect'

        const span = tracer.createSpan(call)
        if (span) {
          span.addProperty('CATEGORY', 'Database')
          span.addProperty('SUBCATEGORY', 'Open')
          span.addProperty('PROVIDER', 'mysql')
          span.addProperty('COMPONENT_CATEGORY', 'Database')
          span.addProperty('COMPONENT_DETAIL', 'Open Connection')
          if (host && port) span.addProperty('URL', host + ':' + port)

          if (typeof args[callbackIndex] !== 'undefined' &&
            Util.isFunction(args[callbackIndex]) &&
            !Util.isMonkeyPatched(args[callbackIndex])) {
            args[callbackIndex] = wrapCallback(args[callbackIndex], span)
          } else {
            let noopCallback = wrapCallback(function noop () {}, span)
            args.unshift(noopCallback)
          }
        }

        return original.apply(this, args)
      }
    }
  }
  function wrapCallback (cb, span, preHook) {
    if (Util.isFunction(preHook)) {
      preHook()
    }
    let wrappedCallback = shimmer.wrap(cb, null, function wrapConnect (original) {
      return tracer.bindSpanCallback(function wrappedCallback () {
        if (span) {
          tracer.endSpan(span)
        }
        return original.apply(this, arguments)
      }, span)
    })
    return typeof wrappedCallback !== 'undefined' ? wrappedCallback : cb
  }
}
