'use strict'
const Util = require('./../util')
const METHODS = ['del', 'get', 'head', 'opts', 'post', 'put', 'patch']

/**
 * restify module instrumentation
 * https://www.npmjs.com/package/restify
 * @param restify
 * @param tracer
 * @param shimmer
 * @param version
 */
module.exports = function (restify, tracer, shimmer, version) {
  shimmer.wrap(restify, 'createServer', wrapCreateServer)

  let wrappedServerClass = false

  return restify

  /**
   * Wraps create server (only executes once)
   * @param original
   */
  function wrapCreateServer (original) {
    return function wrappedCreateServer () {
      let server = original.apply(this, arguments)

      if (server && !wrappedServerClass) {
        wrappedServerClass = true
        wrapServer(Object.getPrototypeOf(server))
      }

      return server
    }
  }

  /**
   * Wraps all method calls against server prototype
   * @param serverPrototype
   */
  function wrapServer (serverPrototype) {
    METHODS.forEach(method => {
      shimmer.wrap(serverPrototype, method, createWrapServerMethod(method))
    })

    /**
     * Wraps Create Server Method calls - in order to wrap actual request callbacks
     * @param method
     */
    function createWrapServerMethod (method) {
      return function wrapServerMethod (original) {
        return function wrappedServerMethod () {
          let args = Util.argsToArray.apply(this, arguments)
          if (args && args.length > 0) {
            let path = args[0]
            let cb = args[args.length - 1]
            if (Util.isFunction(cb) && !Util.isMonkeyPatched(cb)) {
              cb = shimmer.wrap(cb, null, function wrapMethodCallback (original) {
                return wrapCallback(original, path, 'restify.' + method)
              })
              if (cb) {
                args[args.length - 1] = cb
              }
            }
          }

          return original.apply(this, args)

          /**
           * Wrap method callback - updated REPORTING_URL w/ passed in PATH
           * @param cb
           * @param path
           * @param call
           */
          function wrapCallback (cb, path, call) {
            return function wrappedCallback () {
              let rootSpan = tracer.getActiveRootSpan()
              if (rootSpan) {
                rootSpan.addProperty('REPORTING_URL', path)
              }
              const span = tracer.createSpan(call)
              if (span) {
                span.addProperty('CATEGORY', 'Framework')
                span.addProperty('SUBCATEGORY', 'Restify')
                span.addProperty('COMPONENT_CATEGORY', 'Framework')
                span.addProperty('COMPONENT_DETAIL', 'Restify')
                span.addProperty('PATH', path)
              }
              let result = tracer.bindSpanCallback(cb, span).apply(this, arguments)
              if (span) {
                tracer.endSpan(span)
              }
              return result
            }
          }
        }
      }
    }
  }
}
