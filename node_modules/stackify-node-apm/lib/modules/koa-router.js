'use strict'

const semver = require('semver')
const Logger = require('../logger')

const METHODS = ['all', 'delete', 'get', 'head', 'post', 'put', 'patch']

/**
 * Koa-router Instrumentation
 * Creates spans for each route a request flows through.
 * @param Router
 * @param tracer
 * @param shimmer
 * @param version
 */
module.exports = function (Router, tracer, shimmer, version) {
  if (semver.satisfies(version, '^7')) {
    wrapKoaRouter7(Router)
  }

  function wrapKoaRouter7 (Router) {
    METHODS.forEach(method => {
      shimmer.wrap(Router.prototype, method, createPathCallbackWrap('koa-router.Router', method))
    })

    shimmer.wrap(Router.prototype, 'use', wrapKoaRouterUse)
    shimmer.wrap(Router.prototype, 'match', wrapKoaRouterMatch)
  }

  /**
   * Wrapping Router.use calls - https://www.npmjs.com/package/koa-router#exp_module_koa-router--Router
   * Workflow wrapKoaRouterUse -> wrapCallback
   */
  function wrapKoaRouterUse (original) {
    return function () {
      let call = 'koa-router.router'
      let method = 'use'

      if (arguments) {
        if (arguments.length === 1) {
          let callback = arguments[0]
          callback = wrapCallback(callback, call, undefined, method)
          arguments[0] = callback
        } else if (arguments.length === 2) {
          let path = arguments[0]
          let callback = arguments[1]
          callback = wrapCallback(callback, call, path, method)
          arguments[1] = callback
        }
      }

      return original.apply(this, arguments)
    }
  }

  /**
   * Wrapping Router.match calls - https://www.npmjs.com/package/koa-router#new-routeropts
   * Workflow wrapKoaRouterUse -> wrapCallback
   */
  function wrapKoaRouterMatch (original) {
    return function (_, method) {
      const span = tracer.createSpan('koa-router.' + method.toLowerCase())
      let matched = original.apply(this, arguments)

      if (matched && matched.pathAndMethod && matched.pathAndMethod.length) {
        let match = matched.pathAndMethod[matched.pathAndMethod.length - 1]
        let path = match && match.path
        if (typeof path === 'string') {
          if (span) {
            span.addProperty('PATH', path)
          }
        } else {
          Logger.debug('unexpected path type in koa-router prototype.match: %s', typeof path)
        }
      } else {
        Logger.debug('unexpected match result in koa-router prototype.match: %s', typeof matched)
      }
      if (span) {
        tracer.endSpan(span)
      }
      return matched
    }
  }

  /**
   * Generic wrap method creator for functions that accept a path and callback (use/METHODS).
   * @param call
   * @param method
   */
  function createPathCallbackWrap (call, method) {
    return wrapMethod

    function wrapMethod (original) {
      return function () {
        let path = arguments[0]
        // callback argument is what will be executed on each request - this is what needs to be wrapped to create spans
        let callback = arguments[1]
        callback = wrapCallback(callback, call, path, method)
        arguments[1] = callback

        return original.apply(this, arguments)
      }
    }
  }

  /**
   * Wraps callback that will create a span when executed (see wrapCallbackExecution)
   * Workflow: wrapCallback -> wrapCallbackExecution
   * @param callback (callback or Array of callbacks)
   * @param call
   * @param path
   * @param method
   * @return wrapped callback(s)
   */
  function wrapCallback (callback, call, path, method) {
    if (callback) {
      if (typeof callback === 'function') {
        callback = wrapCallbackExecution(callback, call, path, method)
      } else if (Array.isArray(callback)) {
        for (let i = 0; i < callback.length; i++) {
          let cb = callback[i]
          if (typeof cb === 'function') {
            cb = wrapCallbackExecution(cb, call, path, method)
          }
          callback[i] = cb
        }
      }
    }
    return callback
  }

  /**
   * Wraps execution of passed in callback, creates span in trace referencing path/method referenced.
   * @param callback
   * @param call
   * @param path
   * @param method
   */
  function wrapCallbackExecution (callback, call, path, method) {
    return function () {
      const span = tracer.createSpan(call + '.' + method)
      if (span && path) {
        span.addProperty('PATH', formatPath(path))
      }
      let result = tracer.bindSpanCallback(callback, span).apply(this, arguments)
      if (span) {
        tracer.endSpan(span)
      }
      return result
    }
  }

  /**
   * Takes a string or Array of string objects and returns a comman separated string
   * @param path string or array of strings
   */
  function formatPath (path) {
    let formattedPath = path
    if (path) {
      if (Array.isArray(path)) {
        formattedPath = path.join('|')
      }
    }
    return formattedPath
  }
}
