'use strict'

const httpCommon = require('./http-common')
const Util = require('../util')
const Logger = require('../logger')
const URL = require('url')
const endOfStream = require('end-of-stream')
const semver = require('semver')
const stringify = require('json-stringify-safe')

const SHOULD_WRAP_HTTPS = semver.satisfies(process.version, '>=9.0.0 || 8.9.0')
/**
 * http module instrumentation
 * https://nodejs.org/api/http.html
 * @param http
 * @param tracer
 * @param shimmer
 * @param version
 */
module.exports = function (http, tracer, shimmer, version, name) {
  const IS_HTTPS = name === 'https'

  shimmer.wrap(http && http.Server && http.Server.prototype, 'emit', wrapEmit)

  if (http && http.ServerResponse && http.ServerResponse.prototype) {
    shimmer.wrap(http.ServerResponse.prototype, 'writeHead', wrapWriteHead)
    shimmer.wrap(http.ServerResponse.prototype, 'end', wrapRespEnd)
  }

  if (!IS_HTTPS) {
    tracer.httpPatched = true
  }
  // As of node 0.8, http.request() is the right way to originate outbound
  // requests. From 0.11 until 9, the `https` modulew simply called through to
  // the `http` methods, so to prevent double-instrumenting we need to check
  // what module we're instrumenting and what version of Node we're on. This
  // change originally also appeared in 8.9.0 but was reverted in 8.9.1.
  //
  // TODO: Remove `SHOULD_WRAP_HTTPS` after deprecating Node <9.
  if (SHOULD_WRAP_HTTPS || !IS_HTTPS || (IS_HTTPS && !tracer.httpPatched)) {
    Logger.debug('Shimming http request')
    shimmer.wrap(http, 'request', httpCommon.wrapRemoteRequestCall(tracer, (!IS_HTTPS ? 'http' : 'https') + '.request.external'))
  } else {
    Logger.debug('Shimming http request proxy')
    shimmer.wrap(http, 'request', function wrapHttpGet (original) {
      return function wrappedHttpGet () {
        let args = Util.argsToArray.apply(this, arguments)
        // Lets secretly hide a property that helps determine the call
        if (Util.isFunction(args[1]) && typeof args[1].fromGet === 'undefined') {
          args[1].fromGet = (!IS_HTTPS ? 'http' : 'https') + '.request.external'
        }
        return tracer.bindSpanCallback(original, undefined, 'http.request.external - ' + (args[0] ? args[0] : ' No url')).apply(this, args)
      }
    })
  }
  if ((!IS_HTTPS && semver.satisfies(process.version, '>=8')) || (IS_HTTPS && SHOULD_WRAP_HTTPS)) {
    Logger.debug('Shimming http get')
    shimmer.wrap(http, 'get', httpCommon.wrapRemoteRequestCall(tracer, (!IS_HTTPS ? 'http' : 'https') + '.get.external'))
  } else {
    Logger.debug('Shimming http get proxy')
    shimmer.wrap(http, 'get', function wrapHttpGet (original) {
      return function wrappedHttpGet () {
        let args = Util.argsToArray.apply(this, arguments)
        // Lets secretly hide a property that helps determine the call
        if (Util.isFunction(args[1])) {
          args[1].fromGet = (!IS_HTTPS ? 'http' : 'https') + '.get.external'
        }
        return tracer.bindSpanCallback(original, undefined, 'http.get.external - ' + (args[0] ? args[0] : ' No url')).apply(this, args)
      }
    })
  }

  return http

  /**
   * Wrap http request start
   * @param original
   */
  function wrapEmit (original) {
    return function wrappedEmit (event, req, res) {
      if (event === 'request') {
        Logger.debug('Instrumentation:HTTP:beginRequest - Start HTTP Request for transaction')
        return tracer.runInTransaction((IS_HTTPS ? 'https.request' : 'http.request'), wrappedRequestEmit).apply(this, arguments)
      }

      return original.apply(this, arguments)

      function wrappedRequestEmit (event, req, res) {
        tracer.bindEmitter(req)
        tracer.bindEmitter(res)
        let span = tracer.getActiveSpan()

        if (span) {
          // We know if a span is created successfully after a transaction
          createTransactionInfo(span.getTransaction(), req, res)
          span.addProperty('METHOD', req.method)
          let url = URL.parse((req.connection.encrypted ? 'https' : 'http') + '://' + req.headers.host + req.url)
          span.addProperty('URL', Util.removeTrailingSlash(url.href))
          setRequestDetailProps(span, req)
        }

        endOfStream(res, endOfStreamCallback)
        function endOfStreamCallback (err) {
          let txInfo = res.txInfo || null
          if (txInfo) {
            for (var i = txInfo.spanStack.length - 1; i >= 0; --i) {
              tracer.endSpan(txInfo.spanStack[i])
            }
          }
          Logger.debug('Instrumentation:HTTP:endRequest - Request has ended')
          if (err) {
            Logger.debug('Instrumentation:HTTP:endRequest - transaction has ended early', err)
            tracer.endTransaction()
          }
          let activeSpan = tracer.getActiveRootSpan()
          if (activeSpan) {
            setResponseHeaderProps(activeSpan, res)
            activeSpan.addProperty('STATUS', res.statusCode)
            tracer.endTransaction()
          }
        }
        try {
          return original.apply(this, arguments)
        } catch (err) {
          tracer.addErrorToActiveTransaction(err)
          endOfStreamCallback(err)
          throw err
        }
      }
    }
  }

  /**
   * Stores transaction info in request and
   * response objects
   * @param {*} transaction
   * @param {*} request
   * @param {*} response
   */
  function createTransactionInfo (transaction, request, response) {
    if (!request || !response) {
      Logger.debug('Missing request or response object! Not storing transaction info.')
      return
    }

    var txInfo = {
      transaction: transaction,
      spanStack: [], // Need to observe
      errorHandled: false,
      error: null
    }
    request['txInfo'] = response['txInfo'] = txInfo // Make this into constant

    Logger.debug(
      'Stored transaction %s information on request and response',
      transaction.id()
    )
  }

  /**
   * Wrap write head to inject the stackify id for unit testing
   * @param {*} original
   */
  function wrapWriteHead (original) {
    return function wrappedWriteHead () {
      Logger.debug('Shimming http.ServerResponse@writeHead')
      let activeTransaction = tracer.getActiveTransaction()
      let config = tracer.getConfiguration()
      let stackifyId
      let cookieData

      if (activeTransaction) {
        stackifyId = tracer.getStackifyId(activeTransaction.id())
      } else {
        Logger.debug('Http.ServerResponse.writeHead - No active transaction found')
      }

      if (!stackifyId && this.txInfo) {
        stackifyId = tracer.getStackifyId(this.txInfo.transaction.id())
      } else {
        Logger.debug('Http.ServerResponse.writeHead - No transaction info found')
      }

      if (stackifyId) {
        this.setHeader('X-StackifyID', stackifyId)
      }

      if (config.rumEnabled && activeTransaction) {
        cookieData = `${config.rumCookieName}=${activeTransaction.id()}; path=${config.rumCookiePath}`
        this.setHeader('Set-Cookie', cookieData)
      }

      return original.apply(this, arguments)
    }
  }

  /**
   * Wrap the ServerResponse.end method and get the Response body details
   * @param {*} original
   */
  function wrapRespEnd (original) {
    return function wrappedRespEnd (responseBody) {
      Logger.debug('Shimming http.ServerResponse@end')
      let span = tracer.getActiveRootSpan()
      setResponseBodyProps(span, responseBody)

      return original.apply(this, arguments)
    }
  }

  /**
   * Get the Request header/body details
   * @param {Object} span
   * @param {Object} res
   */
  function setRequestDetailProps (span, req) {
    if (span && span.getTransaction().getConfiguration().prefixEnabled) {
      let reqHeadersAry = []
      let reqHeadersObj = req.headers
      for (let key in reqHeadersObj) {
        if (reqHeadersObj.hasOwnProperty(key)) {
          Util.pushToAry(reqHeadersAry, key.toString(), reqHeadersObj[key].replace(/%/g, '%%').toString())
        }
      }

      span.addProperty('PREFIX_REQUEST_HEADERS', stringify(reqHeadersAry))

      let requestBody = ''
      req.on('data', chunk => {
        requestBody += chunk.toString()
      })
      req.on('end', () => {
        let requestBytes = Buffer.byteLength(requestBody, 'utf8')
        span.addProperty('PREFIX_REQUEST_BODY', requestBody.replace(/%/g, '%%').toString())
        span.addProperty('PREFIX_REQUEST_SIZE_BYTES', requestBytes.toString())
      })
    }
  }

  /**
   * Get the Response header details
   * @param {Object} span
   * @param {Object} res
   */
  function setResponseHeaderProps (span, res) {
    if (span && span.getTransaction().getConfiguration().prefixEnabled) {
      let headerString = res._header
      if (headerString) {
        let resHeadersAry = []
        let rawHeader = headerString.split('\r\n')
        rawHeader.forEach(function (item, index) {
          if (index) {
            let idx = item.indexOf(':')
            let key = item.split(':')[0].trim()
            let val = item.substring(idx + 1).trim()
            if (val) {
              Util.pushToAry(resHeadersAry, key, val)
            }
          }
        })
        span.addProperty('PREFIX_RESPONSE_HEADERS', stringify(resHeadersAry))
      }
    }
  }

  /**
   * Get the Response body details
   * @param {Object} span
   * @param {String} responseBody
   */
  function setResponseBodyProps (span, responseBody) {
    if (span && span.getTransaction().getConfiguration().prefixEnabled) {
      if (responseBody) {
        let responseBytes = Buffer.byteLength(responseBody, 'utf8')
        span.addProperty('PREFIX_RESPONSE_BODY', responseBody.toString().replace(/%/g, '%%').toString())
        span.addProperty('PREFIX_RESPONSE_SIZE_BYTES', responseBytes.toString())
      }
    }
  }
}
