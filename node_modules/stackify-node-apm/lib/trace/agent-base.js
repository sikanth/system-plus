'use strict'

const TraceFormatter = require('./formatter')
const Util = require('../util')
const Logger = require('../logger')
const path = require('path')
const StackifyProtoBuf = require(path.join(__dirname, '../../lib/proto/stackify-trace_pb'))
var self = null

/**
 * Base class that will create a Protobuf messages.
 * @constructor
 */
function AgentBase () {
  self = this
  self._traceFormatter = new TraceFormatter()
}

/**
 * This method will build transactions to Stackify::Trace object.
 * It will accept Array of transactions. Return Stackify::Traces
 * @return {!proto.stackify.Traces}
 */
AgentBase.prototype.build_message = function (transactions) {
  try {
    var traceAry = []
    var traces = new StackifyProtoBuf.Traces()
    for (let i = 0; i < transactions.length; i++) {
      let transaction = transactions[i]
      if (transaction.isLoggedState()) {
        continue // FIXME: Do nothing?
      }
      var data = self._traceFormatter.formatTransaction(transaction, true)
      var protobufTransaction = AgentBase.prototype.build_protobuf(data)
      traceAry.push(protobufTransaction)
      transaction.setStateLogged() // Add transaction as logged
    }
    traces.setTracesList(traceAry) // Repeated
    return traces
  } catch (error) {
    Logger.debug('AgentBase.build_message error:' + error)
  }
}

/**
 * This method will build a Protobuf object.
 * It will accept transaction object. Return Stackify::Trace
 * @return {!proto.stackify.Trace}
 */
AgentBase.prototype.build_protobuf = function (data) {
  try {
    // create Trace object
    var trace = new StackifyProtoBuf.Trace()
    // create TraceFrame object
    var traceFrame = new StackifyProtoBuf.TraceFrame()
    traceFrame.setCall(data['call'].toString())
    traceFrame.setStartTimestampMillis(data['reqBegin'])
    traceFrame.setEndTimestampMillis(data['reqEnd'])
    // Map properties
    var propsMap = traceFrame.getPropertiesMap()
    for (var key in data['props']) {
      propsMap.set(key.toString(), data['props'][key].toString())
    }
    // TraceException
    var traceEx = new StackifyProtoBuf.TraceException()
    if (!Util.isUndefined(data['exceptions'])) {
      data['exceptions'].forEach(function (ex) {
        traceEx.setCaughtBy(ex['CaughtBy'])
        traceEx.setException(ex['Exception'])
        traceEx.setMessage(ex['Message'])
        traceEx.setTimestampMillis(ex['Timestamp'])
        if (!Util.isUndefined(ex['lFrames'])) {
          var exFrameAry = []
          var traceExFrame = new StackifyProtoBuf.TraceExceptionFrame()
          ex['Frames'].forEach(function (exFrame) {
            traceExFrame.setSourceMethod(exFrame['Method'])
            exFrameAry.push(traceExFrame)
          })
        }
        traceEx.setFramesList(exFrameAry) // Repeated
        traceFrame.addExceptions(traceEx)
      })
    }
    AgentBase.prototype.add_child_frame(traceFrame, data)
    trace.setFrame(traceFrame)

    return trace
  } catch (error) {
    Logger.debug('AgentBase.build_protobuf error:' + error)
  }
}

/**
 * This method will build a TraceFrame object.
 * It will create a parent-child structure if there is :stacks found in the current level
 * @return {!proto.stackify.TraceFrame}
 */
AgentBase.prototype.add_child_frame = function (traceFrame, data) {
  if (!Util.isUndefined(data['stacks'])) {
    data['stacks'].forEach(function (span) {
      // create TraceFrame object
      var childFrame = new StackifyProtoBuf.TraceFrame()
      childFrame.setCall(span['call'].toString())
      childFrame.setStartTimestampMillis(span['reqBegin'])
      childFrame.setEndTimestampMillis(span['reqEnd'])
      // Map properties
      var propsMap = childFrame.getPropertiesMap()
      for (var key in span['props']) {
        propsMap.set(key.toString(), span['props'][key].toString())
      }
      traceFrame.addFrames(childFrame)
      if (!Util.isUndefined(span['stacks']) && span['stacks'].length > 0) {
        AgentBase.prototype.add_child_frame(childFrame, span)
      }
    })
  }
}

/** @class AgentBase */
module.exports = AgentBase
