'use strict'
const https = require('https')
const fs = require('fs')
const path = require('path')
const FS_R_OK = fs.constants ? fs.constants.R_OK : fs.R_OK
const FS_W_OK = fs.constants ? fs.constants.W_OK : fs.W_OK
const FS_F_OK = fs.constants ? fs.constants.F_OK : fs.F_OK

const CONFIG_FILE_LOCATIONS = [
  path.dirname(require.main.filename),
  process.cwd(),
  process.env.HOME,
  path.join(__dirname, '../../../..')
]
const DEFAULT_FILENAME = 'stackify.js'
const SQL_MAX_CHAR_LIMIT = 100000

const Util = module.exports = {
  /**
   * Generate v4 UUID
   * @returns {string}
   */
  makeId: function makeId () {
    let uuid = ''
    let i
    let random
    for (i = 0; i < 32; i++) {
      random = Math.random() * 16 | 0

      if (i === 8 || i === 12 || i === 16 || i === 20) {
        uuid += '-'
      }
      uuid += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16)
    }
    return uuid
  },

  /**
   * Retruns value with trailing slash removed.
   * @param value
   * @returns {*}
   */
  removeTrailingSlash: function (value) {
    if (value) {
      return value.replace(/\/$/, '')
    }
    return value
  },

  removeQueryString: function (value) {
    if (value) {
      let queryIndex = value.indexOf('?')
      if (queryIndex === -1) {
        return value
      }
      return value.substring(0, queryIndex)
    }
    return value
  },

  /**
   * Determines if the given object exists and is a function.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is a function, else false.
   */
  isFunction: function isFunction (obj) {
    return typeof obj === 'function'
  },

  /**
   * This is the preferred function, when used with `.apply`, for converting the
   * `arguments` object into an actual `Array` as it will not cause deopts.
   *
   * @return {Array} An array containing the elements of `arguments`.
   *
   * @see https://github.com/petkaantonov/bluebird/wiki/Optimization-killers
   */
  argsToArray: function argsToArray () {
    let len = arguments.length
    let arr = new Array(len)
    for (let i = 0; i < len; ++i) {
      arr[i] = arguments[i]
    }
    return arr
  },

  /**
   * Determines if the given object exists and is an array.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is an array, else false.
   */
  isArray: function isArray (obj) {
    return obj instanceof Array
  },

  /**
   * Determine the name of an object.
   *
   * @param {*} obj - The object to get a name for.
   *
   * @return {string} The name of the object if it has one, else `<anonymous>`.
   */
  getObjectName: function getObjectName (obj) {
    return String((!obj || obj === true) ? obj : (obj.name || '<anonymous>'))
  },

  /**
   * Ensures the given index is a valid index inside the array.
   *
   * A negative index value is converted to a positive one by adding it to the
   * array length before checking it.
   *
   * @param {number} arrayLength  - The length of the array this index is for.
   * @param {number} idx          - The index to normalize.
   *
   * @return {?number} The adjusted index value if it is valid, else `null`.
   */
  normalizeIndex: function normalizeIndex (arrayLength, idx) {
    if (idx < 0) {
      idx = arrayLength + idx
    }
    return (idx < 0 || idx >= arrayLength) ? null : idx
  },

  /**
   * Checks if the function/object-function is wrapped by the shimmer
   * Shimmer adds a property if the function is wrapped ('__wrapped')
   *
   * @param {Object}
   * @param {?Function}
   *
   * @returns {boolean}
   */
  isMonkeyPatched: function isMonkeyPatched (object, method) {
    if (!object) {
      return false
    }

    if (!method) {
      return typeof object['__wrapped'] !== 'undefined' && object['__wrapped']
    }

    return typeof object[method] !== 'undefined' && typeof object[method]['__wrapped'] !== 'undefined' && object[method]['__wrapped']
  },

  /**
   * Determines if the given object is a number literal.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is a number literal, else false.
   */
  isNumber: function isNumber (obj) {
    return typeof obj === 'number'
  },

  /**
   * Match arity of the wrapped function based on the original function
   * Starting in what we believe to be Node v4 you can set the name and length of
   * a function as properties. This is more ideal than wrapping a function.
   */
  matchArity: function matchArity (original, wrapper) {
    var toDefine = {
      name: { value: original.name },
      length: { value: original.length }
    }

    Object.defineProperties(wrapper, toDefine)

    return wrapper
  },

  /**
   * Takes a string or Array of string objects and returns a comman separated string
   * @param path string or array of strings
   */
  formatPath: function formatPath (path) {
    let formattedPath = path
    if (path) {
      if (Array.isArray(path)) {
        formattedPath = path.join('|')
      }
    }
    return formattedPath
  },

  /**
   * Determines if the given object is a promise instance.
   *
   * @memberof Shim.prototype
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is a promise, else false.
   */
  isPromise: function isPromise (obj) {
    return obj && typeof obj.then === 'function'
  },

  /**
   * Determines if the object wrapped is an object function or
   * a raw callback
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is raw callback being wrapped
   */
  isWrappedFunction: function isWrappedFunction (obj) {
    return obj && typeof obj['__isFunction'] !== 'undefined' && obj['__isFunction']
  },

  /**
   * Determines if the given object is undefined.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is undefined, else false.
   */
  isUndefined: function isUndefined (obj) {
    return typeof obj === 'undefined'
  },

  /**
   * Determines if the given str is empty.
   *
   * @param {*} str - str to check.
   *
   * @return {bool} True if the str is empty, else false.
   */
  isStrEmpty: function isStrEmpty (str) {
    if (typeof str === 'string') {
      if (str.trim() === '') return true
      return false
    } else {
      return true
    }
  },

  /**
   * Gets the original function if it is wrapped
   * @param {*} obj - The object to check.
   *
   * @return {Function} Returns original function if wrapped else just the passed object
   */
  getOriginalFunction: function getOriginalFunction (obj) {
    return obj && typeof obj['__original'] !== 'undefined' ? obj['__original'] : obj
  },

  /**
   * Get property from object
   * @param {*} obj
   * @param {*} property
   */
  getPropertyFromObject: function getPropertyFromObject (obj, property) {
    return obj && typeof obj[property] !== 'undefined' ? obj[property] : undefined
  },

  /**
   * Determines if the given object is an actual object.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is an actual object, else false.
   */
  isObject: function isObject (obj) {
    if (obj === null) {
      return false
    }
    return typeof obj === 'object'
  },

  /**
   * Determines if the given object is an array or collection of array
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the given object is an array or collection of array, else false.
   */
  checkArrayOfFunctionsForever: function checkArrayOfFunctionsForever (routeName) {
    let result = false
    if (Util.isArray(routeName)) {
      for (let i = 0; i < routeName.length; ++i) {
        if (Util.isArray(routeName[i])) {
          result = checkArrayOfFunctionsForever(routeName[i])
        } else if (Util.isFunction(routeName[i])) {
          result = true
        }
        if (result) {
          break
        }
      }
    }
    return result
  },

  /**
   * Parses a route object and get its string version
   *
   * @param {RegExp|string} route - The object to check.
   *
   * @return {string}
   */
  parseRoute: function parseRoute (route) {
    return route instanceof RegExp ? '/' + route.source + '/'
      : typeof route === 'string' ? route
        : '<unknown>'
  },

  /**
   * Determines if the given object is a string.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is a string, else false.
   */
  isString: function isString (obj) {
    return typeof obj === 'string'
  },

  /**
   * Determines if the given object is a boolean.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is a boolean, else false.
   */
  isBoolean: function isBoolean (obj) {
    return typeof obj === 'boolean'
  },
  /**
   * Gets content from a specific URL with UTF-8 encoding
   * @param {*} url
   * @returns {Promise}
   */
  httpGetSecure: function (url) {
    return new Promise((resolve, reject) => {
      https.get(url, res => {
        let body = ''
        res.setEncoding('utf8')
        res.on('data', function (chunk) {
          body += chunk
        })
        res.on('end', function end () {
          resolve(body)
        })
      }).on('error', reject)
    })
  },

  /**
   * Determines if the given object is a stream object.
   *
   * @param {*} obj - The object to check.
   *
   * @return {bool} True if the object is a a stream object, else false.
   */
  isStream: function isStream (obj) {
    return obj && obj.emit && Util.isFunction(obj.emit)
  },

  /**
   * Check if file is writable
   * Not being used at the moment
   * @param {string} filename
   * @param {Function} callback
   */
  isFileWritable: function isFileWritable (filename, callback) {
    if (!filename) {
      throw makeErrorForLogging('Filename must not be empty', 'Util.isFileWritable')
    }

    if (!Util.isString(filename)) {
      throw makeErrorForLogging('Filename must be a string', 'Util.isFileWritable')
    }

    if (!Util.isFunction(callback)) {
      throw makeErrorForLogging('Callback must be a function', 'Util.isFileWritable')
    }

    fs.access(filename, FS_F_OK | FS_W_OK, function (err) {
      if (err) {
        callback(makeErrorForLogging(filename + ' ' + err.code === 'ENOENT' ? 'does not exist' : 'is read-only Code: ' + err.code + ' Message: ' + err.message, 'Util.isFileWritable'))
        return
      }
      callback(null, true)
    })
  },

  /**
   * Check if file is readable
   * Not being used at the moment
   * @param {string} filename
   * @param {Function} callback
   */
  isFileReadable: function isFileReadable (filename, callback) {
    if (!filename) {
      throw makeErrorForLogging('Filename must not be empty', 'Util.isFileReadable')
    }

    if (!Util.isString(filename)) {
      throw makeErrorForLogging('Filename must be a string', 'Util.isFileReadable')
    }

    if (!Util.isFunction(callback)) {
      throw makeErrorForLogging('Callback must be a function', 'Util.isFileReadable')
    }

    fs.access(filename, FS_F_OK | FS_R_OK, function (err) {
      if (err) {
        callback(makeErrorForLogging(filename + ' ' + err.code === 'ENOENT' ? 'does not exist' : 'Error Code: ' + err.code + ' Message: ' + err.message))
        return
      }
      callback(null, true)
    })
  },

  /**
   * Check if file exists
   * @param {string} filename
   * @param {*} callback
   */
  isFileExists: function isFileExists (filename, callback) {
    if (!filename || !callback) {
      throw makeErrorForLogging('Filename and Callback must not be empty', 'Util.isFileExists')
    }

    if (!Util.isString(filename)) {
      throw makeErrorForLogging('Filename must be a string', 'Util.isFileExists')
    }

    if (!Util.isFunction(callback)) {
      throw makeErrorForLogging('Callback must be a function', 'Util.isFileExists')
    }

    fs.access(filename, FS_F_OK, function (err) {
      let exists = true
      if (err) {
        exists = false
      }
      callback(err, exists)
    })
  },

  /**
   * Async copy file to destination via stream
   * @param {string} source
   * @param {string} destination
   * @param {Function} callback
   */
  copyFile: function copyFile (source, destination, callback) {
    if (!source || !destination || !callback) {
      throw makeErrorForLogging('Source, Destination and Callback must not be empty', 'Util.copyFile')
    }

    if (!Util.isString(source) || !Util.isString(destination)) {
      throw makeErrorForLogging('Source and Destination must be a string', 'Util.copyFile')
    }

    if (!Util.isFunction(callback)) {
      throw makeErrorForLogging('Callback must be a function', 'Util.copyFile')
    }

    let srcStream = fs.createReadStream(source, {
      flags: 'r'
    })

    srcStream.on('open', function (fd) {
      manageDestination(srcStream)
    })

    srcStream.once('error', function (err) {
      callback(makeErrorForLogging(err, 'Util.copyFile - srcStream.on(error)'))
    })

    function manageDestination (srcStream) {
      let destStream = fs.createWriteStream(destination, {
        flags: 'w',
        mode: 0o777
      })

      if (srcStream) {
        destStream.once('error', function (err) {
          callback(makeErrorForLogging(err, 'Util.copyFile - manageDestination - destStream.on(error)'))

          if (!srcStream.closed) {
            srcStream.close()
          }
        })

        destStream.on('close', function () {
          callback(null, makeSuccessResponse('Destination stream closed - File: ' + destination, 'Util.copyFile - manageDestination - destStream.on(close)'))
        })

        srcStream.pipe(destStream)
      }
    }
  },

  /**
   * Restore file if removed
   * - Errors were not being logged as the `Logger` instance isn't accessible at
   * this file (`Logger` is dependent or using the `Util` object)
   * @param {string} filename
   * @param {number} processId
   * @param {number} fileDescriptor
   * @param {Function} callback
   */
  restoreLinuxFileIfNotExists: function restoreLinuxFileIfNotExists (filename, processId, fileDescriptor, callback) {
    if (process.platform === 'win32') {
      throw makeErrorForLogging('Windows operating system - Ignoring', 'Util.restoreLinuxFileIfNotExists')
    }

    if (!filename || !processId || !fileDescriptor || !callback) {
      throw makeErrorForLogging('Filename, processId, fileDescriptor, callback fields are required', 'Util.restoreLinuxFileIfNotExists')
    }

    if (!Util.isString(filename)) {
      throw makeErrorForLogging('Filename must be a string', 'Util.restoreLinuxFileIfNotExists')
    }

    if (!Util.isNumber(processId) || !Util.isNumber(fileDescriptor)) {
      throw makeErrorForLogging('ProcessId, fileDescriptor must be a number', 'Util.restoreLinuxFileIfNotExists')
    }

    if (!Util.isFunction(callback)) {
      throw makeErrorForLogging('Callback must be a function', 'Util.restoreLinuxFileIfNotExists')
    }

    let src = path.join('/proc', processId.toString(), 'fd', fileDescriptor.toString())
    let dest = filename

    Util.isFileExists(dest, function (err, exists) {
      if (err && err.code === 'ENOENT') {
        Util.copyFile(src, dest, function (errCopy) {
          if (Util.isError(errCopy)) {
            callback(errCopy)
            return
          }

          callback(null, makeSuccessResponse('File restored - File: ' + dest, 'Util.restoreLinuxFileIfNotExists - isFileExist - copyFile'))
        })
      } else if (err) {
        callback(makeErrorForLogging(err, 'Util.restoreLinuxFileIfNotExists - isFileExist'))
      } else {
        callback(null, makeSuccessResponse('File exists - File: ' + dest, 'Util.restoreLinuxFileIfNotExists - isFileExist'))
      }
    })
  },

  /**
   * Checks if error is for logging
   * @param {Error} err
   */
  isError: function isError (err) {
    return !Util.isUndefined(err) && err instanceof Error
  },

  /**
   * Checks if error is for logging
   * @param {Error} err
   */
  isErrorForLog: function isErrorForLog (err) {
    return Util.isError(err) && !Util.isUndefined(err.forLog)
  },

  /**
   * Check if object is a SuccessResponse instance
   * @param {*} obj
   */
  isSuccessResponse: function isSuccessResponse (obj) {
    return !Util.isUndefined(obj) && obj instanceof SuccessResponse
  },

  /**
   * Push the element to existing array of object
   * @param {ary} array
   * @param {key} string
   * @param {val} string
   */
  pushToAry: function pushToAry (ary, key, val) {
    let obj = {}
    obj[key.toString()] = val
    ary.push(obj)
  },

  /**
   * Push the element to existing array of object with incremented index
   * @param {ary} array
   * @param {key} string
   * @param {val} string
   */
  pushToAryIndex: function (ary, idx, val) {
    let obj = {}
    let i = idx + 1
    obj[i] = val
    ary.push(obj)
  },

  /**
   * Load the stackify configuration file
   */
  loadStackifyConfig: function () {
    for (let i = 0; i < CONFIG_FILE_LOCATIONS.length; i++) {
      let configFile = CONFIG_FILE_LOCATIONS[i]
      if (!configFile) continue
      let filepath = path.join(path.resolve(configFile), DEFAULT_FILENAME)
      if (!fs.existsSync(filepath)) continue
      filepath = fs.realpathSync(filepath)
      if (filepath) {
        return require(filepath).config
      }
    }
  },

  /**
   * Truncate the SQL strings if its number of characters exceed the limit
   * @returns {sqlStr}
   */
  truncateSQL: function (sqlStr, span) {
    if (sqlStr && sqlStr.length > SQL_MAX_CHAR_LIMIT) {
      sqlStr = sqlStr.substring(0, SQL_MAX_CHAR_LIMIT)
      span.addProperty('SQL_TRUNCATED', true)
    }
    return sqlStr
  }
}

/**
 * Success Response class for logging convention for Util
 * @class
 * @param {string} message
 * @param {*} fn
 */
function SuccessResponse (message, fn) {
  this.message = message
  this.fn = fn
}

/**
 * Get message of the success response
 */
SuccessResponse.prototype.getMessage = function getMessage () {
  return this.message
}

/**
 * Get function of the success response
 */
SuccessResponse.prototype.getFunction = function getFunction () {
  return this.fn
}

/**
 * Success response factory
 * @param {string} message
 * @param {*} fn
 */
function makeSuccessResponse (message, fn) {
  return new SuccessResponse(message, fn)
}

/**
 * Error for logging factory
 * @param {string} message
 * @param {*} fn
 */
function makeErrorForLogging (message, fn) {
  if (!message) {
    return
  }

  let error
  if (Util.isError(message)) {
    error = message
    if (Util.isErrorForLog(error)) {
      error.logFn = message.logFn + ' - ' + fn
    }
  } else {
    error = new Error(message)
  }

  error.forLog = true
  error.logFn = fn

  return error
}
