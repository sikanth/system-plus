'use strict'

const path = require('path')
const fs = require('fs')
const Config = require('./config')
const Tracer = require('./tracer')
const Instrumenter = require('./instrumenter')
const Logger = require('./logger')
const LogCleaner = require('./log/cleaner')
const Util = require('./util')
const shimmer = require('./dependencies/shimmer')
const common = require('./common')
const getModuleDetailsFromPath = require('./dependencies/module-details-from-path')

const MODULES = {
  http: 'http',
  https: 'https',
  http2: 'http2',
  mysql: 'mysql',
  'mongodb-core': 'mongodb-core',
  express: 'express',
  redis: 'redis',
  'koa-router': 'koa-router',
  restify: 'restify',
  memcached: 'memcached',
  pg: 'pg',
  'stackify-logger': 'stackify-logger',
  hapi: 'hapi',
  winston: 'winston',
  bunyan: 'bunyan',
  log4js: 'log4js',
  sequelize: 'sequelize',
  handlebars: 'handlebars'
}

const ARGS = {
  FIRST: 0,
  SECOND: 1,
  THIRD: 2,
  LAST: -1
}

const CLS_NAMESPACE = 'stackify'
const CORE_MODULES = ['http']

// Private
let customInstrumentations = Object.create(null)
let parentModule

// We don't expose the log messages in customers stdout/console instead we put it in stackify-node-apm.log
shimmer({
  'logger': function (msg) {
    Logger.debug(msg)
  }
})

/**
 * Profiler
 * Handles orchestration of instrumentation, tracer, configuration.
 * @constructor
 */
function Profiler (disableCleaner, config) {
  this.handleEnvVariables()
  // load passed in configuration or use default
  if (config) {
    this._config = config
  } else {
    this._config = new Config()
  }

  if (!disableCleaner) {
    this._logCleaner = new LogCleaner()
    this._logCleaner.start()
  }

  // setup namespace
  require('cls-hooked').createNamespace(CLS_NAMESPACE)

  this.tracer = new Tracer(CLS_NAMESPACE)
  this.instrumenter = new Instrumenter(this.tracer, shimmer)
  this.tracer.setConfiguration(this._config)
}

/**
 * Instrumentation options
 * @typedef {Object} InstrumentationOptions
 * @property {String} moduleName - Module to be patched
 * @property {OnRequireCallback} onRequire - Callback executed when module is being required
 */
/**
 * Callback executed when module is being required
 * @callback OnRequireCallback
 * @param {Object} library - Original module object
 * @param {Instrumenter} instrumenter - Helper for customer when instrumenting modules
 * @param {String} version - Package version if applicable, process version if none
 * @param {String} moduleName - Absolute file path of the module, If core, just the moduleName
 * @param {String|null} pkgName - package name if available, null if none
 */
/**
 * Add custom instrumentation
* @param {InstrumentationOptions} instrumentationOptions
 */
Profiler.prototype.addInstrumentation = function setIsTesting (instrumentationOptions) {
  if (!instrumentationOptions) {
    Logger.warn('Profiler.addInstrumentation - Failed to add instrumentation - Error: Instrumentation Options is empty')
    return
  }
  if (Util.isUndefined(instrumentationOptions['moduleName'])) {
    Logger.warn('Profiler.addInstrumentation - Failed to add instrumentation - Error: No Module Name Option')
    return
  }
  if (Util.isUndefined(instrumentationOptions['onRequire'])) {
    Logger.warn('Profiler.addInstrumentation - Failed to add instrumentation - Error: No OnRequire Option')
    return
  }
  if (!Util.isString(instrumentationOptions.moduleName)) {
    Logger.warn('Profiler.addInstrumentation - Failed to add instrumentation - Error: Module name is not a string')
    return
  }
  if (!Util.isFunction(instrumentationOptions.onRequire)) {
    Logger.warn('Profiler.addInstrumentation - Failed to add instrumentation - Error: OnRequire is not a function')
    return
  }

  let isLocalFile = false
  if (!parentModule) {
    if (process && process.mainModule) {
      parentModule = process.mainModule
    } else if (require && require.main) {
      parentModule = require.main
    }
  }

  if (!parentModule) {
    let parent = module
    while (parent !== null) {
      parent = parent.parent
      if (parent.parent === null) {
        parentModule = parent
        break
      }
    }
  }

  if (!isLocalFile) {
    let first3Chars = instrumentationOptions.moduleName.slice(0, 3)
    isLocalFile = first3Chars === '../' || first3Chars === '..\\'
    if (!isLocalFile) {
      let first2Chars = first3Chars.slice(0, 2)
      isLocalFile = first2Chars === './' || first3Chars === '.\\'
    }
  }

  if (isLocalFile) {
    let moduleNameKey = moduleResolveFilename(instrumentationOptions.moduleName)
    if (!Util.isString(moduleNameKey)) {
      Logger.warn('Profiler.addInstrumentation - Failed to add instrumentation - Local Module - Error: %s - Module Name: %s',
        moduleNameKey.message,
        instrumentationOptions.moduleName
      )
    }

    customInstrumentations[moduleNameKey] = instrumentationOptions
    return
  }

  let moduleNameKey = moduleResolveFilename(instrumentationOptions.moduleName)

  if (Util.isString(moduleNameKey) && !isLocalFile) {
    customInstrumentations[moduleNameKey] = instrumentationOptions
    return
  }

  Logger.warn('Profiler.addInstrumentation - Failed to add instrumentation - Error: %s - Module Name: %s',
    moduleNameKey.message,
    instrumentationOptions.moduleName
  )
}

/**
 * Resolves file name of module
 * @param {string} module
 * @param {Module} parentModule
 *
 * @returns {Error|String} Returns false if it was not able to resolve the module, else absolute path
 */
function moduleResolveFilename (module) {
  let Module = require('module')
  try {
    let resolvedFileName = Module._resolveFilename(module, parentModule)
    return resolvedFileName
  } catch (err) {
    return err
  }
}

/**
 * Sets profiler status to testing mode
 * @param {bool} isTesting
 */
Profiler.prototype.setIsTesting = function setIsTesting (isTesting) {
  this.tracer.setIsTesting(isTesting)
}

/**
 * Start the profiler
 */
Profiler.prototype.start = startProfiler

function startProfiler () {
  startInstrumentation.call(this, this.tracer, this)
  return this
}

/**
 * Get configuration
 * @returns {Config}
 */
Profiler.prototype.getConfiguration = function () {
  return this._config
}

/**
 * Get custom instrumentations
 * @returns {*} - List of custom instrumentations
 */
Profiler.prototype.getCustomInstrumentations = function getCustomInstrumentations () {
  return customInstrumentations
}

/**
 * Get custom instrumentations Length
 * - Used in testing
 * @returns {Integer} - Custom instrumentation Length
 */
Profiler.prototype.getCustomInstrumentationsLength = function getCustomInstrumentationsLength () {
  return Object.keys(customInstrumentations).length
}

/**
 * Clear custom instrumentation
 * - Only used in testing
 */
Profiler.prototype.clearCustomInstrumentations = function clearCustomInstrumentations () {
  Object.keys(customInstrumentations).forEach(function (prop) {
    delete customInstrumentations[prop]
  })
}

/**
 * Get custom instrumentations
 * @returns {*} - List of custom instrumentations
 */
Profiler.prototype.getCustomInstrumentations = function getCustomInstrumentations () {
  return customInstrumentations
}

/**
 * Get custom instrumentations Length
 * - Used in testing
 * @returns {Integer} - Custom instrumentation Length
 */
Profiler.prototype.getCustomInstrumentationsLength = function getCustomInstrumentationsLength () {
  return Object.keys(customInstrumentations).length
}

/**
 * Clear custom instrumentation
 * - Only used in testing
 */
Profiler.prototype.clearCustomInstrumentations = function clearCustomInstrumentations () {
  Object.keys(customInstrumentations).forEach(function (prop) {
    delete customInstrumentations[prop]
  })
}

/**
 * Wraps module require functions for instrumentation
 * @param {*} tracer
 */
function wrapModuleRequire (tracer, profiler) {
  let Module = require('module')
  let resolvedNameObject

  /**
   * Patches resolve filename getting executed inside the Module._load function
   * - We will save the last file name getting resolved and will use the absolute
   *   path for file checking
   */
  shimmer.wrap(Module, '_resolveFilename', function wrapResolveFilename (original, name) {
    return function wrappedResolveFilename () {
      let result = original.apply(this, arguments)
      if (resolvedNameObject) {
        resolvedNameObject.name = result
      }
      resolvedNameObject = undefined
      return result
    }
  })
  /**
   * Responsible for modules getting required and caching it once it has been loadeds
   * - Resolve file name is getting load here
   * - We will process the exported module and check if its already patched or included
   *   for instrumentation
   */
  shimmer.wrap(Module, '_load', function wrapLoad (original, name) {
    return function wrappedLoad (file, parentContext) {
      let newObject = {
        name: ''
      }
      resolvedNameObject = newObject
      let result = wrapExport(original.apply(this, arguments), file, newObject)
      return result
    }
  })

  /**
   * Handles patching of node modules
   * @param {*} exportedModule
   * @param {*} moduleName
   * @param {*} fullFilePath
   * @returns {*} Patched export object
   */
  function wrapExport (exportedModule, moduleName, resolvedFileName) {
    if (Util.isUndefined(exportedModule)) {
      Logger.debug('Profiler: wrapExport - no module set - Module: ' + moduleName)
      return exportedModule
    }

    if (!Util.isUndefined(exportedModule['_stackifyPatched'])) {
      Logger.debug('Profiler: wrapExport - module already patched - Module: ' + moduleName)
      return exportedModule
    }

    let fullFilePath = resolvedFileName ? resolvedFileName.name : null
    let isCustomInstrumentation = false
    let isInstrumentable = false
    let fullFileCustomInstrumentable = false
    let moduleNameCustomInstrumentable = false

    if (!Util.isUndefined(MODULES[moduleName])) {
      isInstrumentable = true
    }

    if (!isInstrumentable) {
      fullFileCustomInstrumentable = !Util.isUndefined(customInstrumentations[fullFilePath])
      moduleNameCustomInstrumentable = !Util.isUndefined(customInstrumentations[moduleName])

      isCustomInstrumentation = moduleNameCustomInstrumentable || fullFileCustomInstrumentable
      isInstrumentable = isCustomInstrumentation
    }

    if (!isInstrumentable) {
      return exportedModule
    }

    let pkg
    let version
    let pkgName
    let patched
    let basedir
    let moduleInfo
    let isCoreModule

    if (fullFilePath) {
      moduleInfo = getModuleDetailsFromPath(fullFilePath)
      isCoreModule = fullFilePath.indexOf('\\') === -1 && fullFilePath.indexOf('/') === -1
    }

    if (moduleInfo) {
      basedir = moduleInfo.basedir
    } else {
      basedir = path.dirname(fullFilePath)
    }

    if (!isCoreModule) {
      try {
        pkg = require(path.join(basedir, 'package.json'))
        version = pkg.version
        pkgName = pkg.name
      } catch (e) {
        Logger.warn('Profiler: wrapExport - Module has no package information %s - Error: %s', moduleName, e.message)
        version = null
        pkgName = null
      }
    } else {
      version = common.NODE_VERSION
    }

    Logger.info('Profiler: wrapExport - Shimming %s@%s module', moduleName, version)
    try {
      let fileName = moduleName
      if (moduleName === 'https') {
        fileName = 'http'
      }

      if (!isCustomInstrumentation) {
        let instrumentationFilePath = path.join(__dirname, 'modules', fileName + '.js')
        let instrumentationFullFilePath = path.resolve(instrumentationFilePath)

        if (!fs.existsSync(instrumentationFilePath)) {
          Logger.warn(
            'Profiler: wrapExport - Instrumentation file does not exist - File: %s',
            instrumentationFullFilePath
          )
          return exportedModule
        }

        require(instrumentationFilePath)(exportedModule, tracer, shimmer, version, moduleName)
        patched = true
      } else {
        try {
          let customInstrumentation = customInstrumentations[moduleNameCustomInstrumentable ? moduleName : fullFilePath]
          if (Util.isFunction(customInstrumentation.onRequire)) {
            let result = customInstrumentation.onRequire(exportedModule, profiler.instrumenter, version, moduleName, pkgName)
            if (result !== false && Util.isMonkeyPatched(result)) {
              exportedModule = result
            }
          }
          patched = true
        } catch (err) {
          Logger.warn('Profiler: wrapExport - Custom Instrumentation failed - %s - Error: %s', moduleName, err.message)
        }
      }
    } catch (err) {
      Logger.warn('Profiler: wrapExport - Instrumentation failed - %s - Error: %s', moduleName, err.message)
    }

    if (patched) {
      exportedModule._version = version
      exportedModule._stackifyPatched = true
    }

    return exportedModule
  }
}

function startInstrumentation (tracer, profiler) {
  try {
    require('./modules/core/global')(global, tracer, shimmer, common.NODE_VERSION)
  } catch (err) {
    Logger.warn('Profiler: startInstrumentation - Global module not instrumented - Error: ' + err.message)
  }

  // Add custom instrumentations by user
  addConfigCustomInstrumentations(tracer, profiler)
  wrapModuleRequire(tracer, profiler)

  CORE_MODULES.forEach(function callbackForEach (value, index) {
    try {
      require(value)
    } catch (err) {
      Logger.warn(
        'Profiler: startInstrumentation - Could not load core module %s - Error: %s',
        value,
        err
      )
    }
  })
}

function addConfigCustomInstrumentations (tracer, profiler) {
  let customUserInstrumentations = profiler.getConfiguration().getCustomInstrumentations()
  if (!Util.isObject(customUserInstrumentations)) {
    // Not an object
    return
  }
  let groupedInstrumentations = {}

  // Group by module name
  customUserInstrumentations.forEach(function objectEach (value, index) {
    let moduleName = Util.getPropertyFromObject(value, 'module')
    if (!moduleName) {
      return
    }

    if (!Util.getPropertyFromObject(groupedInstrumentations, moduleName)) {
      groupedInstrumentations[moduleName] = []
    }

    groupedInstrumentations[moduleName].push(value)
  })
  Object.keys(groupedInstrumentations).forEach(function moduleEach (moduleName, index) {
    let trackedClassMethod = {}
    let moduleMethods = groupedInstrumentations[moduleName]

    profiler.addInstrumentation({
      moduleName: moduleName,
      onRequire: function (library, instrumenter, version, name, pkgName) {
        let isFunctionLibrary = library.constructor.name === 'Function'
        let libraryObjectName = Util.getObjectName(library)
        let functionName = (libraryObjectName === '<anonymous>' ? 'Function' : libraryObjectName)
        let libraryName = isFunctionLibrary ? functionName : library.constructor.name
        let libraryPathName = moduleName
        let isLocalFile = false

        if (!isLocalFile) {
          let first3Chars = moduleName.slice(0, 3)
          isLocalFile = first3Chars === '../' || first3Chars === '..\\'
          if (!isLocalFile) {
            let first2Chars = first3Chars.slice(0, 2)
            isLocalFile = first2Chars === './' || first3Chars === '.\\'
          }
        }

        if (isLocalFile) {
          libraryPathName = path.relative(process.cwd(), moduleName)
          libraryPathName = libraryPathName.replace('\\', '/')
        }

        moduleMethods.forEach(function classMethod (instrumentationObject, index) {
          let className = Util.getPropertyFromObject(instrumentationObject, 'class')
          let methodName = Util.getPropertyFromObject(instrumentationObject, 'method')

          if (!methodName && !className) {
            Logger.debug('Profiler.addInstrumentation - onRequire - Class and method name empty (Library: %s, Class: %s, Method: %s)', methodName, className, moduleName)
            return
          }
          let methodSlices = methodName.split('.').filter(function (value) { return value !== '' })
          let methodSlicesLength = methodSlices.length
          methodName = methodSlices.join('.') // Rebuild, clean already
          let classMethodName = (className ? (className + '.') : '') + methodName

          if (!Util.isUndefined(trackedClassMethod[classMethodName])) {
            Logger.debug('Profiler.addInstrumentation - onRequire - Class method name already patched(Library: %s, Class Method Name: %s)', classMethodName, moduleName)
            return
          }

          trackedClassMethod[classMethodName] = true

          if (libraryName !== className) {
            Logger.debug('Profiler.addInstrumentation - onRequire - Library name is not the same with the class name (Library: %s, Class: %s, Module: %s)', libraryName, className, moduleName)
            return
          }

          let isValidProperty = true
          let object
          let property

          for (let index = 0; index < methodSlicesLength; index++) {
            property = methodSlices[index]
            object = Util.isUndefined(object) ? library : object
            if (Util.isUndefined(object[property])) {
              isValidProperty = false
              break
            }
            if (methodSlicesLength !== (index + 1)) {
              object = object[property]
            }
          }

          if (!isValidProperty) {
            Logger.debug('Profiler.addInstrumentation - onRequire - Invalid Property (Library: %s, Class: %s, Method: %s, Module: %s, Method Slices: %s)', libraryName, className, methodName, moduleName, methodSlices)
            return
          }

          let trackedFunction = Util.getPropertyFromObject(instrumentationObject, 'trackedFunction')
          let trackedFunctionName = Util.getPropertyFromObject(instrumentationObject, 'trackedFunctionName')
          let trackedFunctionSetting

          if (
            (Util.isBoolean(trackedFunction) && trackedFunction) ||
            (Util.isString(trackedFunction) && trackedFunction === 'true')
          ) {
            trackedFunctionSetting = true
            if (Util.isString(trackedFunctionName)) {
              trackedFunctionSetting = trackedFunctionName.replace('{{ModuleName}}', moduleName)
            }
          }

          let isPromise
          let isStream
          let promiseOption = Util.getPropertyFromObject(instrumentationObject, 'promise')
          let streamOption = Util.getPropertyFromObject(instrumentationObject, 'stream')

          if (
            (Util.isBoolean(promiseOption) && promiseOption) ||
            (Util.isString(promiseOption) && promiseOption === 'true')
          ) {
            isPromise = true
          }

          if (
            (Util.isBoolean(streamOption) && streamOption) ||
            (Util.isString(streamOption) && streamOption === 'true')
          ) {
            isStream = true
          }

          if (isStream && isPromise) {
            Logger.debug('Profiler.addInstrumentation - onRequire - Function result is both stream and promise (Library: %s, Class: %s, Method: %s, Module: %s, Method Slices: %s)', libraryName, className, methodName, moduleName, methodSlices)
          }

          let callbackOption = Util.getPropertyFromObject(instrumentationObject, 'callback')
          let callbackInteger = null
          if (Util.isString(callbackOption) && !Util.isUndefined(ARGS[callbackOption])) {
            callbackInteger = ARGS[callbackOption]
          } else if (Util.isNumber(callbackOption)) {
            callbackInteger = callbackOption
          }

          let spanCall = libraryPathName + '/' + classMethodName
          tracer.watch(object, property, function watchOptionsCallback () {
            let options = {
              createSpan: true,
              spanCall: spanCall,
              spanProperties: {
                'CATEGORY': 'NodeJS'
              }
            }

            if (trackedFunctionSetting) {
              options.trackedFunction = trackedFunctionSetting
            }

            if (isPromise) {
              options.isPromiseResult = true
            }

            if (isStream) {
              options.isStreamResult = true
            }

            if (callbackInteger !== null) {
              options.callbackOptions = {
                wrapper: callbackInteger
              }
            }

            return options
          },
          true)
        })
      }
    })
  })
}
/**
 * Get rum injection content from the rum generator
 */
Profiler.prototype.injectRumContent = function injectRumContent () {
  return this.tracer.injectRumContent()
}

const LogLevels = {
  'DEBUG': 1,
  'INFO': 2,
  'WARN': 3,
  'ERROR': 4
}

/**
 * Handle environment variables
 */
Profiler.prototype.handleEnvVariables = function handleEnvVariables () {
  if (
    !Util.isUndefined(process.env['STACKIFY_DEBUG']) &&
    (
      (Util.isString(process.env['STACKIFY_DEBUG']) && process.env['STACKIFY_DEBUG'] === 'true') ||
      (Util.isBoolean(process.env['STACKIFY_DEBUG']) && process.env['STACKIFY_DEBUG'] === true)
    )
  ) {
    Logger.setLogLevel(LogLevels['DEBUG'])
  }
}

module.exports = Profiler
