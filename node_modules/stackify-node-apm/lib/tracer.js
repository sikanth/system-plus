'use strict'

const Transaction = require('./transaction')
const TraceProcessor = require('./trace/processor')
const Queue = require('./queue')
const Logger = require('./logger')
const Util = require('./util')
const shimmer = require('./dependencies/shimmer')
const Span = require('./span')
const Timer = require('./timer')
const RumGenerator = require('./rum/generator')
const Config = require('./config')
const traceProcessor = new TraceProcessor()

const ARGS = {
  FIRST: 0,
  SECOND: 1,
  THIRD: 2,
  LAST: -1
}

const MIDDLEWARE_TYPE = {
  APPLICATION: 'Application',
  ROUTE: 'Route',
  ROUTER: 'Router',
  MIDDLEWARE: 'Middleware',
  ERRORWARE: 'Errorware'
}

function Tracer (namespace) {
  this._namespace = namespace
  this._transactionMap = null
  this.httpPatched = false
  this._exceptionMapByTransaction = new Map()
  this._exceptionMap = new WeakMap()
  this._config = null
  this._rumGenerator = null

  const tracer = this
  this._config = new Config()
  let type = this._config.getTransportType()

  if (this._config.queueEnabled) {
    this._queue = new Queue(function onFlush (transactions, afterFlushingCallback, setClearOnFlush) {
      if (transactions.length > 0) {
        traceProcessor.process(transactions, type)
      }
      setClearOnFlush(true)
    })
  }

  if (this._config.queueEnabled) {
    this._waitSpanQueue = new Queue({
      onFlush: function onFlush (transactions, afterFlushingCallback, setClearOnFlush, resetInternalTimer, clearTimer, filterItems) {
        Logger.debug('tracer.waitSpanQueue - onFlush - init callback')
        setClearOnFlush(false)
        if (!(transactions && transactions.length)) {
          Logger.debug('tracer.waitSpanQueue - onFlush - No items on queue, clearTimer')
          clearTimer()
          return
        }

        Logger.debug('tracer.waitSpanQueue - onFlush - has transactions, processing - Items: ' + transactions.length)
        let millisElapsed = 60000

        let numRemovedItems = filterItems(
          function onCheck (transaction) {
            return tracer.hasTransactionEnded(transaction) && (tracer.hasTransactionElapsed(transaction, millisElapsed) || !tracer.hasTransactionRunningSpans(transaction))
          },
          function onRemove (transaction, index) {
            Logger.debug('tracer.waitSpanQueue - onFlush - Add to log queue - Transaction Id: ' + transaction.id())
            tracer.addToLogQueue(transaction)
          }
        )
        Logger.debug('tracer.waitSpanQueue - onFlush - To be removed - Remove Items: ' + numRemovedItems)

        Logger.debug('tracer.waitSpanQueue - onFlush - has transactions, processing - Items: ' + transactions.length)
        if (transactions.length) {
          Logger.debug('tracer.waitSpanQueue - onFlush - resetInternalTimer')
          resetInternalTimer()
        } else {
          Logger.debug('tracer.waitSpanQueue - onFlush - clearTimer')
          clearTimer()
        }
      },
      onLimit: function onLimit (transactions, internalFlush) {
        Logger.debug('tracer._waitSpanQueue - on limit init')
        let firstTransaction = transactions.shift() // We are removing the first item directly from the Queue._items array using shift
        if (tracer.hasTransactionRunningSpans(firstTransaction)) {
          Logger.debug('tracer._waitSpanQueue - onLimit - transaction has still span running, adding to log queue - Transaction Id: ' + (firstTransaction && firstTransaction.id && firstTransaction.id()))
        }

        // Add first transaction popped to LogQueue
        tracer.addToLogQueue(firstTransaction)
        // Do not empty out the Queue._items
        internalFlush(false)
      },
      onCheck: function onCheck (obj) {
        return tracer.hasTransactionEnded(obj) && tracer.hasTransactionRunningSpans(obj)
      },
      maxQueueSize: 25,
      name: 'WaitQueue'
    })
  }
}

/**
 * Set configuration
 * @param {Config} config Config instance
 */
Tracer.prototype.setConfiguration = function (config) {
  this._config = config
  Logger.setApplicationName(config.applicationName)
  this._rumGenerator = new RumGenerator(this)
}

/**
 * Set configuration
 * @param {Config} config Config instance
 */
Tracer.prototype.getConfiguration = function () {
  return this._config
}

/**
 * Set apm to testing mode
 * @param {bool} isTesting
 */
Tracer.prototype.setIsTesting = function setIsTesting (isTesting) {
  this._isTesting = isTesting
  if (isTesting) {
    this._transactionMap = new Map()
  }
}

/**
 * Check if apm is in testing
 * @returns {bool}
 */
Tracer.prototype.isTesting = function isTesting () {
  return this._isTesting
}

/**
 * Get request header stackify id
 * @param {*} transactionId
 *
 * @returns {string|null}
 */
Tracer.prototype.getStackifyId = function getStackifyId (transactionId) {
  if (this._config.clientId && this._config.clientDeviceId) {
    return `V1|${transactionId}|C${this._config.getClientId()}|CD${this._config.getClientDeviceId()}|`
  }
  return null
}

/**
 * Get transaction id from stackify id
 * @param {strings} stackifyId
 *
 * @returns {null|string}
 */
Tracer.prototype.getTransactionIdFromStackifyId = function getTransactionIdFromStackifyId (stackifyId) {
  let stackifyIdArray = typeof stackifyId === 'string' ? stackifyId.split('|') : null
  return stackifyIdArray && stackifyIdArray[1]
}

// Span related
/**
 * Create span with call
 * @param {string}
 * @returns {Span}
 */
Tracer.prototype.createSpan = function createSpan (call, isDelay, parent) {
  if (Util.isUndefined(parent) && Util.isObject(isDelay)) {
    parent = isDelay
    isDelay = undefined
  }
  let span = parent || this.getActiveSpan()

  if (!span) {
    Logger.debug('Tracer.createSpan - No active span')
    return false
  } else if (!(span instanceof Span)) {
    Logger.debug('Tracer.createSpan - Invalid span format - Span: %s', JSON.stringify(span))
    return false
  } else if (!span.getTransaction()) {
    Logger.debug('Tracer.createSpan - Span has no transaction - Span: %s', JSON.stringify(span))
    return false
  } else if (span.getTransaction().isLoggedState()) {
    Logger.debug('Tracer.createSpan - Transaction is already logged, ignoring - Call: %s - Id: %s', call, span.getTransaction().id())
    return false
  }

  return span.addChild(call, isDelay)
}

/**
 * End span and add it to waitSpanQueue
 * @param {Span} span
 */
Tracer.prototype.endSpan = function endSpan (span) {
  if (!span) {
    Logger.debug('Tracer.endSpan - Invalid or undefined span provided')
    return
  }

  if (!(span instanceof Span)) {
    Logger.debug('Tracer.endSpan - Span not an instanceof Span class')
    return
  }

  span.end()
  let self = this
  process.nextTick(function onNextTickEndSpan () {
    self.addToWaitSpanQueue(span.getTransaction())
  })
}

/**
 * Returns current active/executing span
 * @returns span
 */
Tracer.prototype.getActiveSpan = function () {
  if (!this.getActiveContext()) {
    Logger.debug('Tracer.getActiveSpan - No active context was found')
    return undefined
  }
  return this.getSession().get('span')
}

/**
 * Sets current active/executing span
 * @param span
 */
Tracer.prototype.setActiveSpan = function setActiveSpan (span) {
  this.getSession().set('span', span)
}

/**
 * Returns root span for current span's transaction
 * @returns span
 */
Tracer.prototype.getActiveRootSpan = function () {
  let span = this.getActiveSpan()
  return span ? span._transaction.rootSpan : null
}

// Transaction related
/**
 * Start current transaction
 * @param {string} call
 * @return {Span} Returns the root span
 */
Tracer.prototype.startTransaction = function startTransaction (call) {
  let activeTransaction = this.getActiveTransaction()
  let transaction = new Transaction(call, this.getConfiguration())
  let span = transaction.rootSpan
  if (this.isTesting()) {
    transaction.parentTransaction = activeTransaction && activeTransaction.id()
  }
  this.getSession().set('transaction', transaction)
  this.getSession().set('span', span)
  Logger.debug('Begin transaction: %s', transaction._id)

  // Set namespace context
  span.setNamespaceContext(this.getActiveContext())
  return span
}

/**
 * End current transaction in context
 */
Tracer.prototype.endTransaction = function endTransaction () {
  let activeRootSpan = this.getActiveRootSpan()
  let activeTransaction = this.getActiveTransaction()
  let tracer = this

  if (activeRootSpan) {
    if (this.hasTransactionEnded(activeTransaction)) {
      Logger.debug('Tracer.endTransaction - Already ended transaction Id: %s', activeTransaction._id)
      return
    }
    activeTransaction.setStateEnd()
    tracer.endSpan(activeRootSpan)
    Logger.debug('Tracer.endTransaction - End transaction Id: %s', activeTransaction._id)
    this.removeExceptionSetByTransactionId(activeTransaction.id())

    if (this.isTesting()) {
      Logger.debug('Tracer.endTransaction - Add transaction to map: %s', activeTransaction.id())
      this._transactionMap.set(activeTransaction.id(), activeTransaction)
    }
  }
}

/**
 * Sets current active/executing transaction
 * @param transaction
 */
Tracer.prototype.setActiveTransaction = function setActiveTransaction (transaction) {
  this.getSession().set('transaction', transaction)
}

/**
 * Returns current active/executing transaction
 * @returns transaction
 */
Tracer.prototype.getActiveTransaction = function () {
  let span = this.getActiveSpan()
  return span ? span._transaction : null
}

/**
 * Get transaction from transaction map (for testing)
 * @param {*} transactionId
 */
Tracer.prototype.getTransaction = function (transactionId) {
  if (this._transactionMap) {
    let result = this._transactionMap.get(transactionId)
    if (typeof result !== 'undefined') {
      Logger.debug('Get transaction Id: ' + transactionId + ' - parent transaction - ' + (result && result.parentTransaction))
      this._transactionMap.delete(transactionId)
      return result
    }
  }
  return null
}

/**
 * Check if there are spans running
 * @param {obj} transaction
 * @returns {boolean}
 */
Tracer.prototype.hasTransactionRunningSpans = function hasTransactionRunningSpans (transaction) {
  return transaction && transaction.rootSpan ? checkSpanIsRunning(transaction.rootSpan) : false

  // Check if there are spans running
  function checkSpanIsRunning (span) {
    let result = span ? span.reqEnd === null : false
    if (result) {
      return true
    }

    if (span && span.stacks && span.stacks.length) {
      for (let i = 0; i < span.stacks.length; i++) {
        result = checkSpanIsRunning(span.stacks[i])
        if (result) {
          break
        }
      }
    }
    return result
  }
}

/**
 * Check if the transaction has elapsed the said time
 * @param {Transaction} transaction
 * @param {Number} elapsedMillis
 * @returns {boolean}
 */
Tracer.prototype.hasTransactionElapsed = function hasTransactionElapsed (transaction, elapsedMillis) {
  let transactionEnd = transaction && transaction.rootSpan && transaction.rootSpan.reqEnd
  if (!transactionEnd) {
    Logger.debug('tracer.hasTransactionElapsed - invalid transaction, ignore')
    return true
  }

  if (elapsedMillis === undefined || (!Util.isUndefined(elapsedMillis) && !Util.isNumber(elapsedMillis))) {
    Logger.debug('tracer.hasTransactionElapsed - invalid time elapsed, ignore')
    return true
  }

  if (elapsedMillis < 1) {
    Logger.debug('tracer.hasTransactionElapsed - invalid time elapsed, ignore')
    return true
  }

  let currentTimeMillis = (new Timer()).getCurrentTime()
  let timeDiffMillis = currentTimeMillis - transactionEnd
  return timeDiffMillis > elapsedMillis
}

/**
 * Check if the transaction has ended
 * @param {obj} transaction
 * @returns {boolean}
 */
Tracer.prototype.hasTransactionEnded = function hasTransactionEnded (transaction) {
  if (!transaction) {
    Logger.debug('tracer.hasTransactionEnded - not transaction, ignore')
    return false
  }
  if (!transaction.rootSpan) {
    Logger.debug('tracer.hasTransactionEnded - invalid transaction, ignore')
    return false
  }
  if (!(transaction instanceof Transaction)) {
    Logger.debug('tracer.hasTransactionEnded - transaction is not a valid Transaction object - ' + (typeof transaction.id !== 'undefined' ? transaction.id() : ''))
    return false
  }
  if (!transaction.isEndState()) {
    Logger.debug('tracer.hasTransactionEnded - transaction has not ended - ' + (typeof transaction.id !== 'undefined' ? transaction.id() : ''))
    return false
  }
  return true
}

// Queue related
/**
 * Add Transaction to LogQueue
 * @param {Transaction} transaction
 * @returns {bool|null}
 */
Tracer.prototype.addToLogQueue = function addToLogQueue (transaction) {
  if (transaction instanceof Transaction) {
    if (transaction.isPendingLogState()) {
      Logger.debug('tracer.addToLogQueue - failed to add to log queue, transaction already in pending log state or already logged - Transaction Id: ' + (transaction && transaction.id()))
      return false
    }

    if (!this.hasTransactionEnded(transaction)) {
      Logger.debug('tracer.addToLogQueue - transaction is still running - Transaction Id: ' + transaction.id())
      return false
    }

    Logger.debug('tracer.addToLogQueue - add to log queue - Transaction Id: ' + (transaction && transaction.id()))

    if (this._config.queueEnabled && this._queue) {
      // add transaction to queue if enabled and available
      const addResult = this._queue.add(transaction)
      if (addResult === null) {
        Logger.debug('tracer.addToLogQueue - transaction already exist in the queue, not doing anything - Transaction Id: ' + transaction.id())
      } else {
        transaction.setStatePendingLog() // Set wait log state since we add it already to the log queue
      }
      return addResult
    } else {
      // process transaction without queue
      let type = this._config.getTransportType()
      traceProcessor.process([transaction], type)
      return true
    }
  }
  Logger.debug('tracer.addToLogQueue - invalid transaction, failed to add to log queue')
  return false
}

/**
 * Add transaction to wait span queue to wait for spans to finish
 * @param {Transaction} transaction
 * @returns {boolean|null}
 */
Tracer.prototype.addToWaitSpanQueue = function addToWaitSpanQueue (transaction) {
  if (transaction && transaction instanceof Transaction) {
    if (this._config.queueEnabled && this._waitSpanQueue) {
      if (transaction.isPendingWaitSpanState()) {
        Logger.debug('tracer.addToWaitSpanQueue - transaction is already in waitSpan state, not adding - Transaction Id: ' + transaction.id())
        return false
      }

      if (!this.hasTransactionEnded(transaction)) {
        Logger.debug('tracer.addToWaitSpanQueue - transaction is still running - Transaction Id: ' + transaction.id())
        return false
      }

      let addResult = this._waitSpanQueue.add(transaction)
      if (addResult === null) {
        Logger.debug('tracer.addToWaitSpanQueue - transaction already exist in the queue, not doing anything - Transaction Id: ' + transaction.id())
      } else if (addResult === false) {
        // It is not qualified for the waitSpanQueue, add to log queue directly
        // We already checked if the transaction has already ended
        this.addToLogQueue(transaction)
      } else {
        Logger.debug('tracer.addToWaitSpanQueue - setting transaction state to pending wait span - Transaction Id: ' + transaction.id())
        transaction.setStatePendingWaitSpan()
      }

      return addResult
    } else {
      // process transaction without queue
      if (this.hasTransactionEnded(transaction)) {
        this.addToLogQueue(transaction)
        return true
      }
    }
  }
  Logger.debug('tracer.addToWaitSpanQueue - invalid transaction')
  return false
}

/**
 * Force flushes wait span queue and flush the logger queue
 */
Tracer.prototype.forceFlushQueue = function forceFlushQueue () {
  let tracer = this
  if (this._waitSpanQueue) {
    this._waitSpanQueue.forceClearAndCustomFlush(function customFlushCallback (items) {
      if (items && items.length) {
        items.forEach(function (value, index) {
          tracer.addToLogQueue(value)
        })
      }
      if (tracer._queue) {
        tracer._queue.flush()
      }
    })
  }
}

// Exception Related
/**
 * Check if the exception has been already tracked to that specific transaction
 */
Tracer.prototype.hasExceptionByTransactionId = function getExceptionByTransactionId (transactionId, exception) {
  let exceptionSet = this.getExceptionSetByTransactionId(transactionId)
  return exceptionSet && exceptionSet.has(exception)
}

/**
 * Get exception set by transaction id in order to add new exceptions
 */
Tracer.prototype.getExceptionSetByTransactionId = function getExceptionByTransactionId (transactionId) {
  return this._exceptionMapByTransaction &&
    this._exceptionMapByTransaction.get(transactionId)
}

/**
 * Remove exception set by transaction id in order to add new exceptions
 */
Tracer.prototype.removeExceptionSetByTransactionId = function removeExceptionSetByTransactionId (transactionId) {
  let exceptionSetRemoved = this._exceptionMapByTransaction &&
    this._exceptionMapByTransaction.delete(transactionId)
  if (!exceptionSetRemoved) {
    Logger.debug('tracer.removeExceptionSetByTransactionId - Removed non existing transaction exception set - Transaction Id: %s', transactionId)
  }
  return exceptionSetRemoved
}

/**
 * Add exception to the set by transaction id
 */
Tracer.prototype.setExceptionByTransactionId = function getExceptionByTransactionId (transactionId, exception) {
  let exceptionSet = this.getExceptionSetByTransactionId(transactionId)
  return exceptionSet && exceptionSet.add(exception)
}

/**
 * Add exception into the set. Creates transaction exception set if empty
 */
Tracer.prototype.addExceptionByTransactionId = function addExceptionByTransactionId (transactionId, exception) {
  if (!this._exceptionMapByTransaction.has(transactionId)) {
    let exceptionSet = new WeakSet()
    this._exceptionMapByTransaction.set(transactionId, exceptionSet)
    exceptionSet.add(exception)
    Logger.debug('tracer.addExceptionByTransactionId - Exception set not found, creating Transaction Id: %s - Error: %s', transactionId, exception.message)
    return true
  } else if (!this.hasExceptionByTransactionId(transactionId, exception)) {
    this.setExceptionByTransactionId(transactionId, exception)
    Logger.debug('tracer.addExceptionByTransactionId - Exception set found, adding Transaction Id: %s - Error: %s', transactionId, exception.message)
    return true
  }

  return false
}

/**
 * Add error to active transaction (if present)
 * @param err
 */
Tracer.prototype.addErrorToActiveTransaction = function (err, transaction) { // eslint-disable-line handle-callback-err
  let activeTransaction = transaction || this.getActiveTransaction()
  if (activeTransaction) {
    if (this.addExceptionByTransactionId(activeTransaction.id(), err)) {
      activeTransaction.addException(err)
      // Add exception to set
      this._exceptionMap.set(err, activeTransaction.id())
    }
  } else {
    if (!this._exceptionMap.has(err)) {
      this._exceptionMap.set(err, undefined)
      Logger.debug('tracer.addErrorToActiveTransaction - Exception not tracked - No active transaction - Error: %s', err.message)
    } else {
      Logger.debug('tracer.addErrorToActiveTransaction - Exception already tracked - No active transaction - Error: %s', err.message)
    }
  }
}

// Context preservation related

/**
 * Bind options for a wrapped callback
 * @typedef {Object} BindOptions
 * @property {boolean} captureTime - If true, we will time the function execution
 * @property {boolean} captureActiveSpanTime - If true, we will update the active span end time
 * @property {HookInCallback} hookIn - Parent span should me attach on to
 */

/**
 * Sets active span to the callback in order
 * to preserve context for the current execution
 *
 * @param {Function} callback Callback to be wrapped
 * @param {Span} span Active span to be bounded
 * @param {?string} functionName Function name to be logged
 * @param {BindOptions} bindOptions in context callback
 *
 * @returns {Function} - boundWrappedCallback
 */
Tracer.prototype.bindSpanCallback = function bindSpanCallback (callback, span, functionName, bindOptions) {
  if (!Util.isFunction(callback)) {
    Logger.warn('Tracer.bindSpanCallback - callback is not a function, not wrapping - ' + functionName)
    return callback
  }

  if (Util.isObject(functionName)) {
    bindOptions = functionName
    functionName = undefined
  }

  if (Util.isObject(span) && !(span instanceof Span)) {
    bindOptions = span
    span = this.getActiveSpan()
  }

  let tracer = this
  let namespaceContext
  let activeSpan = span || this.getActiveSpan()

  if (!bindOptions) {
    bindOptions = Object.create(null)
  }

  if (!activeSpan) {
    Logger.warn('Tracer.bindSpanCallback - there is no active span, not wrapping - ' + functionName)
    return callback
  }

  if (!(activeSpan instanceof Span)) {
    Logger.warn('Tracer.bindSpanCallback - span is not an instance of Span - ' + functionName)
    return callback
  }

  if (!activeSpan.getNamespaceContext() && !this.getActiveSpan()) {
    Logger.warn('Tracer.bindSpanCallback - active Span has no active context - ' + functionName)
    return callback
  }

  if (Util.isMonkeyPatched(callback)) {
    Logger.warn('Tracer.bindSpanCallback - callback is already wrapped, not wrapping - ' + functionName)
    return callback
  }

  // Wrapping the callback using the shimmer in order to check the function easily if
  // it has been monkeypatched. Inside the wrappedContextCallback is where the magic
  // happens. We create a new context in the transaction namespace ensuring that it wont
  // be corrupted and setting the active span to be the one passed or the active one in
  // the transaction. After wrapping the callback execution in a context. We check the
  // the result if it is a promise object then we add a new property to the promise object
  // that to be retrieved during resolution/rejection. Then return the result expected
  // from the callback
  let wrappedCallback = shimmer.wrap(callback, null, function wrapNewContextCallback (original, methodName) {
    return function wrappedNewContextCallback () {
      let self = this
      let args = Util.argsToArray.apply(this, arguments)

      if (activeSpan.getNamespaceContext()) {
        namespaceContext = activeSpan.getNamespaceContext()
      }

      if (!namespaceContext && !tracer.hasSessionContext()) {
        Logger.warn('Tracer.bindSpanCallback - there is no active session context, not wrapping - ' + functionName)
        return original.apply(self, args)
      }

      let currentContext = namespaceContext || tracer.getActiveContext()
      if (!currentContext) {
        Logger.error('wrappedNewContextCallback - no context found')
        return original.apply(self, args)
      }
      // Create a new context and set the new active span
      try {
        return tracer.getSession().bind(function wrappedContextCallback () {
          let prevSpan = tracer.getActiveSpan()
          let activeTransaction = tracer.getActiveTransaction()
          let captureActiveSpanTime = Util.getPropertyFromObject(bindOptions, 'captureActiveSpanTime')
          let captureTime = Util.getPropertyFromObject(bindOptions, 'captureTime')

          try {
            if (captureActiveSpanTime && prevSpan && prevSpan !== activeTransaction.rootSpan) {
              prevSpan.captureTime()
            }

            let args = Util.argsToArray.apply(this, arguments)
            tracer.setActiveSpan(activeSpan)
            if (captureTime) {
              activeSpan.start()
            }

            let hookIn = Util.getPropertyFromObject(bindOptions, 'hookIn')
            if (hookIn && Util.isFunction(hookIn)) {
              hookIn.call(this, original, args, methodName, activeSpan)
            }

            let result = original.apply(this, args)
            return result
          } catch (e) {
            throw e
          } finally {
            if (captureTime) {
              activeSpan.captureTime()
            }
            tracer.setActiveSpan(prevSpan)
          }
        }, currentContext).apply(self, args)
      } catch (e) {
        const ERROR_SYMBOL = 'error@context'
        if (typeof (e[ERROR_SYMBOL]) !== 'undefined') {
          delete e[ERROR_SYMBOL]
        }
        throw e
      }
    }
  })

  if (typeof wrappedCallback !== 'undefined') {
    return wrappedCallback
  }
  Logger.error('Tracer.bindSpanCallback - callback is not wrapped, something went wrong  - ' + functionName)
  return callback
}

/**
 * Binds event emitter to the current active context available
 * to preserve context in every event handler
 *
 * @param {EventEmitter} emitter
 *
 * @returns {WrappedEventEmitter}
 */
Tracer.prototype.bindEmitter = function bindEmitter (emitter, span) {
  let activeSpan = span || this.getActiveSpan()
  if (!emitter || !emitter.emit) {
    return emitter
  }

  let origEmit = Util.getOriginalFunction(emitter.emit)
  emitter.emit = this.bindSpanCallback(origEmit, activeSpan)
  return emitter
}

/**
 * Wraps current handler in a transaction
 * each execution is equivalent to a new transaction
 *
 * @param {*} transactionName
 * @param {*} callback
 *
 * @returns {Function}
 */
Tracer.prototype.runInTransaction = function runInTransaction (transactionName, callback) {
  const tracer = this

  if (typeof transactionName !== 'string' || !transactionName) {
    Logger.warn('Tracer.runInTransaction - transactionName is not set or invalid')
    return callback
  }

  if (!Util.isFunction(callback)) {
    Logger.warn('Tracer.runInTransaction - callback is not a function, not wrapping')
    return callback
  }

  if (Util.isMonkeyPatched(callback)) {
    Logger.warn('Tracer.runInTransaction - callback is already wrapped, not wrapping')
    return callback
  }

  let wrappedCallback = shimmer.wrap(callback, null, function wrapTransactionCallback (original, name) {
    return function wrappedTransactionCallback () {
      let self = this
      let args = Util.argsToArray.apply(this, arguments)
      let result

      tracer.getSession().run(function boundTransactionCallback () {
        tracer.startTransaction(transactionName)
        result = original.apply(self, args)
      })
      return result
    }
  })

  if (typeof wrappedCallback !== 'undefined') {
    return wrappedCallback
  }

  Logger.warn('Tracer.runInTransaction - Callback is not wrapped')
  return callback
}

/**
 * Returns thread-local session
 * @returns {*}
 */
Tracer.prototype.getSession = function getSession () {
  return require('cls-hooked').getNamespace(this._namespace)
}

/**
 * Check if session has active context
 * @returns {*}
 */
Tracer.prototype.hasSessionContext = function hasSessionContext () {
  return !!this.getActiveContext()
}

/**
 * Get session active context
 * @returns {*}
 */
Tracer.prototype.getActiveContext = function getActiveContext () {
  return this.getSession().active
}

/**
 * Responsible for setting options for watch function
 * @callback WatchOptionsCallback
 * @param {Object} original - Original module object
 * @param {string} methodName - Original module name
 * @param {array} args - Arguments passed when the original module was executed
 * @returns {WatchOptions} Options for watching a function
 */

/**
 * Watch options needed to track a function
 * @typedef {Object} WatchOptions
 * @property {boolean} createSpan - If true, we will create span for the observed function
 * @property {Span} parentSpan - Parent span should we attach on to
 * @property {boolean} isPromiseResult - Adds flag that result is a Promise object
 * @property {boolean} isStreamResult - Adds flag that result is a Stream object
 * @property {string} spanCall - Span call to be displayed
 * @property {Object} spanProperties - Span properties describing the observed function
 * @property {CallbackOptions} callbackOptions - Interval before the queue flushes
 * @property {HookOptions} hookOptions - Name of the queue (in case there are different approaches)
 */

/**
 * Watch options needed to track a function
 * @typedef {Object} CallbackOptions
 * @property {CallbackWrapper|Integer} wrapper
 * - If it is an integer, we will observe it as argument index
 * - If the value is negative, we will start counting from the last argument.
 * - If the argument is a function then we will follow the CallbackWrapper specs.
 */

/**
 * Hook options in case we want to analyze or manipulate within different parts of the execution
 * @typedef {Object} HookOptions
 * @property {HookCheckCallback} hookCheck - Hook for span checking
 * @property {HookInCallback} hookIn - Hook getting executed in context
 * @property {HookPreCallback} hookPre - Hook before function is getting executed
 * @property {HookAfterCallback} hookAfter - Hook after function is getting executed and result intervention
 */

/**
 * Hook function for checking before proceeding in creating span
 * @callback HookCheckCallback
 * @param {Object} original - Original module object
 * @param {array} args - Arguments passed when the original module was executed
 * @param {string} methodName - Original module name
 *
 * @returns {boolean} Return true if it passes the check otherwise false
 */

/**
 * Hook getting executed in context
 * @callback HookInCallback
 * @param {Object} original - Original module object
 * @param {array} args - Arguments passed when the original module was executed
 * @param {string} methodName - Original module name
 * @param {Span} activeSpan - Active span during the duration of the observed function
 */

/**
 * Hook after function is getting executed and result intervention
 * @callback HookAfterCallback
 * @param {Object} original - Original module object
 * @param {array} args - Arguments passed when the original module was executed
 * @param {string} methodName - Original module name
 * @param {Span} activeSpan - Active span during the duration of the observed function
 * @param {*} result - Result from the executing function
 * @param {*} err - Error object passed if there is an error occured
 */

/**
 * Hook before function is getting executed
 * @callback HookPreCallback
 * @param {Object} original - Original module object
 * @param {array} args - Arguments passed when the original module was executed
 * @param {string} methodName - Original module name
 * @param {Span} activeSpan - Active span during the duration of the observed function
 */

/**
 * Allows to modify a callback on the arguments passed on the original module function
 * @callback CallbackWrapper
 * @param {Object} original - Original module object
 * @param {string} methodName - Original module name
 * @param {array} args - Arguments passed when the original module was executed
 * @param {Span} activeSpan - Active span during the duration of the observed function
 * @returns {undefined|WrappedFunction} It depends if the wrapper was a callback function or an integer (arg index)
 */

/**
 * Wrapped function definition
 * @typedef {Object|Function} WrappedFunction
 * @property {Object|Function} __original - Original function/object
 * @property {Function} __unwrap - Used to unwrapped function to original function/object
 * @property {boolean} __wrapped - Sets object to true if wrapped
 * @property {boolean} __isFunction - If the wrapped object is a plain callback function, else it is a property in an object
 */

/**
  * Watches a function and records it in a span
  * @param {Object|Function} library - The source for the properties to wrap, or a single function to wrap.
  * @param {string|Array.<string>} properties - One or more properties to wrap. If omitted, the `library` parameter is assumed to be the function to wrap.
  * @param {WatchOptionsCallback} watchOptionsCallback - The options for watching a function
  * @param {boolean|undefined} fromJson - Determines if the watch function is called from the custom instrumentation json
  * @returns {WrappedFunction} Returns the patched function
  */
Tracer.prototype.watch = function watch (library, properties, watchOptionsCallback, fromJson) {
  let tracer = this

  if (Util.isFunction(properties)) {
    fromJson = watchOptionsCallback
    watchOptionsCallback = properties
    properties = null
  }

  if (properties && !Util.isArray(properties)) {
    if (typeof properties === 'string') {
      properties = [properties]
    } else {
      properties = null
    }
  }

  if (!Util.isFunction(watchOptionsCallback)) {
    Logger.debug('Tracer.watch - watchOptionsCallback - Not a function')
    return library
  }

  if (properties === null) {
    return shimmer.wrap(library, null, wrapMethod)
  }

  // Wrap one by one
  properties.forEach(function callbackFn (value, index) {
    shimmer.wrap(library, value, wrapMethod)
  })

  return library

  function wrapMethod (original, methodName) {
    if (!Util.isFunction(original)) {
      Logger.debug('Not a function')
      return original
    }

    if (Util.isMonkeyPatched(original)) {
      return original
    }

    if (fromJson) {
      let originalKeys = Object.keys(original)
      if (originalKeys.length) {
        wrappedMethod = Object.assign(wrappedMethod, original) // eslint-disable-line
      }
    }

    return wrappedMethod

    function wrappedMethod () {
      let args = Util.argsToArray.apply(this, arguments)
      let options = watchOptionsCallback.call(this, original, methodName, args)

      if (!options) {
        options = Object.create(null)
      }

      let createSpan = !Util.isUndefined(options['createSpan']) ? options['createSpan'] : false
      let checkArity = !Util.isUndefined(options['checkArity']) ? options['checkArity'] : false // eslint-disable-line
      let parentSpan = !Util.isUndefined(options['parentSpan']) && options['parentSpan'] instanceof Span ? options['parentSpan'] : tracer.getActiveSpan()
      let isPromiseResult = !Util.isUndefined(options['isPromiseResult']) ? options['isPromiseResult'] : false
      let isStreamResult = !Util.isUndefined(options['isStreamResult']) ? options['isStreamResult'] : false

      if (!parentSpan) {
        Logger.debug('Tracer.watch - wrappedMethod - parentSpan - No running transaction or active span, not watching - ' + JSON.stringify(options))
        return original.apply(this, args)
      }

      let hookOptions = Util.getPropertyFromObject(options, 'hookOptions')
      let hookCheck

      hookCheck = Util.getPropertyFromObject(hookOptions, 'hookCheck')
      if (Util.isFunction(hookCheck)) {
        let resultCheck = hookCheck.call(this, original, args, methodName)
        if (Util.isUndefined(resultCheck)) {
          return original.apply(this, args)
        }
        if (!resultCheck) {
          return original.apply(this, args)
        }
      }

      let activeSpan
      if (createSpan) {
        let spanCall = Util.getPropertyFromObject(options, 'spanCall')
        if (!spanCall) {
          Logger.debug('Tracer.watch - wrappedMethod - spanCall - No span call was set')
          return original.apply(this, args)
        }

        if (typeof spanCall !== 'string') {
          Logger.debug('Tracer.watch - wrappedMethod - spanCall - Span call is not a string')
          return original.apply(this, args)
        }
        activeSpan = tracer.createSpan(spanCall, true, parentSpan)
      }

      if (!activeSpan) {
        Logger.debug('Tracer.watch - wrappedMethod - activeSpan - No span was created')
        return original.apply(this, args)
      }

      let spanProperties = Util.getPropertyFromObject(options, 'spanProperties')
      if (spanProperties && Util.isObject(spanProperties)) {
        Object.keys(spanProperties).forEach(function forEach (value, index) {
          if (typeof spanProperties[value] === 'string') {
            activeSpan.addProperty(value, spanProperties[value])
          }
        })
      }

      let trackedFunction = Util.getPropertyFromObject(options, 'trackedFunction')
      if (trackedFunction) {
        let trackedFunctionCall = activeSpan.call
        let addTrackedFunc = false
        let isCallback = properties === null

        let isFunctionLibrary = library.constructor.name === 'Function'
        let libraryObjectName = Util.getObjectName(library)

        let libraryFunctionName = libraryObjectName === '<anonymous>' ? 'Function' : libraryObjectName
        let libraryName = isFunctionLibrary ? libraryFunctionName : library.constructor.name

        let className = isCallback ? '' : libraryName
        let isPrototypeFunction = methodName && !Util.isUndefined(library.constructor.prototype[methodName])
        let functionName = (isPrototypeFunction ? 'prototype.' : '') + (methodName !== null ? methodName : Util.getObjectName(original))

        if (Util.isString(trackedFunction)) {
          addTrackedFunc = true
          if (trackedFunction !== 'true') {
            trackedFunctionCall = trackedFunction
          }
        } else if (Util.isBoolean(trackedFunction) && trackedFunction) {
          addTrackedFunc = true
        }

        if (addTrackedFunc) {
          trackedFunctionCall = trackedFunctionCall.replace('{{ClassName}}', className)
          trackedFunctionCall = trackedFunctionCall.replace('{{MethodName}}', functionName)

          activeSpan.addProperty('TRACKED_FUNC', trackedFunctionCall)
        }
      }

      let callbackOptions = Util.getPropertyFromObject(options, 'callbackOptions')
      if (callbackOptions) {
        let callbackWrapper = Util.getPropertyFromObject(callbackOptions, 'wrapper')
        if (typeof callbackWrapper !== 'undefined') {
          if (Util.isFunction(callbackWrapper)) {
            callbackWrapper.call(this, original, methodName, args, activeSpan)
          } else if (Util.isNumber(callbackWrapper)) {
            let callbackIndex = Util.normalizeIndex(args.length, callbackWrapper)
            if (callbackIndex !== null) {
              let callbackBindOptions = {}
              if (fromJson) {
                callbackBindOptions['captureActiveSpanTime'] = true
              }
              args[callbackIndex] = tracer.bindSpanCallback(args[callbackIndex], activeSpan, callbackBindOptions)
            }
          }
        } else {
          Logger.debug('Tracer.watch - wrappedMethod - callbackWrapper - No callback wrapper was set')
        }
      }

      let hookPre
      let hookIn
      let hookAfter
      let bindOptions = Object.create(null)

      if (createSpan) {
        bindOptions['captureTime'] = true
      }

      if (hookOptions) {
        hookIn = Util.getPropertyFromObject(hookOptions, 'hookIn')
        if (Util.isFunction(hookIn)) {
          bindOptions['hookIn'] = hookIn
        }

        hookPre = Util.getPropertyFromObject(hookOptions, 'hookPre')
        if (Util.isFunction(hookPre)) {
          hookPre.call(this, original, args, methodName, activeSpan)
        }

        hookAfter = Util.getPropertyFromObject(hookOptions, 'hookAfter')
        hookAfter = Util.isFunction(hookAfter) ? hookAfter : false
      }

      let result
      let error
      let promiseResult = false
      try {
        result = tracer.bindSpanCallback(original, activeSpan, bindOptions).apply(this, args)
        if (hookAfter && isPromiseResult && Util.isPromise(result)) {
          // Add continuation and update the span timestamp
          promiseResult = true
          result.then(function onFulfilled (value) {
            activeSpan.captureTime()
            hookAfter.call(this, original, args, methodName, activeSpan, value)
            return value
          }, function onRejected (err) {
            activeSpan.captureTime()
            hookAfter.call(this, original, args, methodName, activeSpan, undefined, err)
            throw err
          })
        }
      } catch (e) {
        error = e
        throw e
      } finally {
        if (hookAfter && (!promiseResult || error)) {
          hookAfter.call(this, original, args, methodName, activeSpan, result, error)
        }
      }

      if (result) {
        if (isPromiseResult && Util.isPromise(result)) {
          result.then(function onFulfilled (value) {
            activeSpan.captureTime()
            return value
          }, function onRejected (err) {
            activeSpan.captureTime()
            throw err
          })
        }

        if (isStreamResult && Util.isStream(result)) {
          shimmer.wrap(result, 'emit', function wrapEmit (original, name) {
            if (!Util.isFunction(original)) {
              return original
            }

            if (Util.isMonkeyPatched(original)) {
              return original
            }

            return function wrappedEmit (event) {
              if (!activeSpan) {
                return original.apply(this, arguments)
              }

              if (event === 'end' || event === 'error') {
                activeSpan.captureTime()
              }

              return tracer.bindSpanCallback(original, activeSpan).apply(this, arguments)
            }
          })

          // Also wrap up any listeners for end or error events.
          shimmer.wrap(result, 'on', makeWrapOnAddListener(activeSpan))
          shimmer.wrap(result, 'once', makeWrapOnAddListener(activeSpan))
          shimmer.wrap(result, 'addListener', makeWrapOnAddListener(activeSpan))
          shimmer.wrap(result, 'prependListener', makeWrapOnAddListener(activeSpan))
        }
      }

      return result
    }
  }
  function makeWrapOnAddListener (activeSpan) {
    return function wrapOnAddListener (original, name) {
      if (!Util.isFunction(original)) {
        return original
      }

      if (Util.isMonkeyPatched(original)) {
        return original
      }

      return function wrappedOnAddListener () {
        if (!activeSpan) {
          return original.apply(this, arguments)
        }

        let args = Util.argsToArray.apply(this, arguments)
        let callbackIndex = Util.normalizeIndex(args.length, ARGS.LAST)
        if (callbackIndex !== null) {
          tracer.bindSpanCallback(args, callbackIndex, activeSpan)
        }

        return original.apply(this, args)
      }
    }
  }
}

/**
 * Responsible for setting options for watch function
 * @callback SetupMiddlewareMethodOptionsCallback
 * @param {Object} original - Original module object
 * @param {string} methodName - Original module name
 * @returns {SetupMiddlewareMethodOptions} Options for watching a function
 */

/**
 * Watch options needed to track a function
 * @typedef {Object} SetupMiddlewareMethodOptions
 * @property {RouteOptions} routeOptions - If true, we will create span for the observed function
 * @property {MiddlewareOptions} middlewareOptions - Parent span should me attach on to
 */

/**
 * Route options responsible for the request details
 * @typedef {Object} RouteOptions
 * @property {Number|String} routeArgPosition - If number, it will be normalized and retrieved from the arguments, else it will be just a route string
 */

/**
 * Middleware options responsible for wrapping the middleware mounter
 * @typedef {Object} MiddlewareOptions
 * @property {MiddlewareCallbackWrapper} middlewareWrapper - Responsible for wrapping the middleware handler
 * @property {WrapOptions} middlewareWrapperOptions - Additional wrapping options for the middleware
 */

/**
 * Allows to modify a callback on the arguments passed on the original module function
 * @callback MiddlewareCallbackWrapper
 * @param {Function} middlewareHandler - Middleware handler
 * @param {string} middlewareHandlerName - Middleware handler name
 * @param {string} routeName - Current route for the specific handler
 * @param {string} methodName - Middleware mounter method name
 * @param {WrapOptions} middlewareWrapperOptions - Additional wrapping options for the middleware
 * @returns {Object|WrappedFunction} Wrapped object/function
 */

/**
  * Patches the function responsible for attaching middlewares
  * @param {Object|Function} library - The source for the properties to wrap, or a single function to wrap.
  * @param {string|Array.<string>} properties - One or more properties to wrap. If omitted, the `library` parameter is assumed to be the function to wrap.
  * @param {SetupMiddlewareMethodOptionsCallback} setupOptionsCallback - The options for watching a function
  * @returns {WrappedFunction} Returns the patched function
  */
Tracer.prototype.setupMiddlewareMethod = function setupMiddlewareMethod (library, properties, setupOptionsCallback) {
  if (Util.isFunction(properties)) {
    setupOptionsCallback = properties
    properties = null
  }

  if (properties && !Util.isArray(properties)) {
    if (typeof properties === 'string') {
      properties = [properties]
    } else {
      properties = null
    }
  }

  if (properties === null) {
    return shimmer.wrap(library, null, wrapMiddlewareMethod)
  }

  // Wrap one by one
  properties.forEach(function callbackFn (value, index) {
    shimmer.wrap(library, value, wrapMiddlewareMethod)
  })

  return library
  function wrapMiddlewareMethod (original, methodName) {
    if (!Util.isFunction(original)) {
      Logger.debug('Not a function')
      return original
    }
    let setupOptions = setupOptionsCallback(original, methodName)
    let routeOptions = Util.getPropertyFromObject(setupOptions, 'routeOptions')
    let middlewareOptions = Util.getPropertyFromObject(setupOptions, 'middlewareOptions')
    let middlewareWrapperOptions

    return function wrappedMiddlewareMethod () {
      let args = Util.argsToArray.apply(this, arguments)
      let routeIndex
      let routeName
      let middlewareWrapper

      if (setupOptions) {
        if (routeOptions) {
          let routeArgPosition = Util.getPropertyFromObject(routeOptions, 'routeArgPosition')
          if (Util.isNumber(routeArgPosition)) {
            routeIndex = Util.normalizeIndex(args.length, routeArgPosition)
            routeName = routeIndex === null ? null : args[routeIndex]
            const isArrayOfFunctionsOrArray = Util.checkArrayOfFunctionsForever(routeName)

            if (Util.isFunction(routeName) || isArrayOfFunctionsOrArray) {
              routeIndex = null
              routeName = null
            } else if (Util.isArray(routeName)) {
              for (let i = 0; i < routeName.length; ++i) {
                routeName[i] = Util.parseRoute(routeName[i])
              }
            } else {
              routeName = Util.parseRoute(routeName)
            }
          } else if (routeArgPosition !== null) {
            routeName = Util.parseRoute(routeArgPosition) // If the route provided by the specifications is string
          }

          if (middlewareOptions) {
            middlewareWrapper = Util.getPropertyFromObject(middlewareOptions, 'middlewareWrapper')
            if (middlewareWrapper && Util.isFunction(middlewareWrapper)) {
              middlewareWrapperOptions = Util.getPropertyFromObject(middlewareOptions, 'middlewareWrapperOptions')
              wrapMiddlewares.call(this, routeIndex, routeName, methodName, args)
            }
          }
        }
      }

      return original.apply(this, args)

      function wrapMiddlewares (routeIndex, routeName, methodName, middlewareMethodArgs) {
        for (let i = 0; i < middlewareMethodArgs.length; ++i) {
          let middlewareHandler = middlewareMethodArgs[i]
          if (Util.isArray(middlewareHandler)) {
            wrapMiddlewares(null, routeName, methodName, middlewareHandler)
            continue
          }

          if (i === routeIndex) {
            continue
          }

          if (!middlewareHandler) {
            continue
          }

          middlewareMethodArgs[i] = middlewareWrapper.call(
            this,
            middlewareHandler,
            Util.getObjectName(middlewareHandler),
            routeName,
            methodName,
            middlewareWrapperOptions
          )
        }
      }
    }
  }
}

/**
 * Responsible for setting options for watch function
 * @callback WatchMiddlewareOptionsCallback
 * @param {Object} original - Original module object
 * @param {string} methodName - Original module name
 * @param {array} args - Arguments passed when the original module was executed
 * @returns {WatchMiddlewareOptions} Options for watching a function
 */

/**
 * Middleware options responsible for wrapping the middleware mounter
 * @typedef {Object} WatchMiddlewareOptions
 * @property {string} framework - Framework used
 * @property {string} routeName - Route name/path
 * @property {string} middlewareMethodName - Middleware method name used for mounting
 * @property {string} middlewareName - Middleware handler name
 * @property {string} middlewareType - Middleware type (e.g Middleware, Errorware etc.)
 * @property {Number|MiddlewareRequestObjectCallback} middlewareRequestObject - Gets request object from arguments if integer, if function, executes the said callback
 * @property {Number|MiddlewareNextObjectCallback} middlewareNextObject - Responsible for wrapping the middleware handler
 * @property {boolean} middlewareCheckArity - Checks middleware function arity to match with the original one
 * @property {boolean} middlewareIsPromise - If middleware return value is a Promise object
 */

/**
 * Generates the request object from the arguments
 * @callback MiddlewareRequestObjectCallback
 * @param {Object} library - Original module object
 * @param {string} methodName - Original module name
 * @param {array} args - Arguments passed when the original module was executed
 * @returns {Object} Returns the request object
 */

/**
 * Allows to modify a callback on the arguments passed on the original module function
 * @callback MiddlewareNextObjectCallback
 * @param {Object} library - Original module object
 * @param {string} methodName - Original module name
 * @param {array} args - Arguments passed when the original module was executed
 * @param {Span} activeSpan - Active span active during the execution of the handler function
 * @param {BindNextWrapperCallback} bindNextWrapper - Next/continuation function wrapper not to break the call structure
 */

/**
 * Next/continuation function wrapper not to break the call structure
 * @callback BindNextWrapperCallback
 * @param {Object|Function} library - The source for the properties to wrap, or a single function to wrap.
 * @param {string|Array.<string>} properties - One or more properties to wrap. If omitted, the `library` parameter is assumed to be the function to wrap.
 */

/**
 * Additional wrapping options for the function
 * @typedef {Object} WrapOptions
 * @property {boolean} checkArity - Checks function arity to match with the original one
 */

/**
  * Patches the middleware handler
  * @param {Object|Function} library - The source for the properties to wrap, or a single function to wrap.
  * @param {string|Array.<string>} properties - One or more properties to wrap. If omitted, the `library` parameter is assumed to be the function to wrap.
  * @param {WatchMiddlewareOptionsCallback} watchMiddlewareOptionsCallback - The options for watching a middleware
  * @param {WrapOptions} wrapOptions - Additional wrapping options for the function
  * @returns {WrappedFunction} Returns the patched function
  */
Tracer.prototype.watchMiddleware = function watchMiddleware (library, properties, watchMiddlewareOptionsCallback, wrapOptions) {
  let tracer = this

  if (Util.isFunction(properties)) {
    watchMiddlewareOptionsCallback = properties
    properties = null
  }

  if (properties && !Util.isArray(properties)) {
    if (typeof properties === 'string') {
      properties = [properties]
    } else {
      properties = null
    }
  }

  if (!wrapOptions) {
    wrapOptions = Object.create(null)
  }

  if (properties === null) {
    return shimmer.wrap(library, null, wrapMiddlewareHandler)
  }

  // Wrap one by one
  properties.forEach(function callbackFn (value, index) {
    shimmer.wrap(library, value, wrapMiddlewareHandler)
  })

  return library

  function wrapMiddlewareHandler (original, methodName) {
    let wrapped = wrappedMiddlewareHandler()
    if (Util.getPropertyFromObject(wrapOptions, 'checkArity')) {
      wrapped = Util.matchArity(original, wrapped)
    }

    return wrapped

    function wrappedMiddlewareHandler () {
      if (!Util.isFunction(watchMiddlewareOptionsCallback)) {
        return original
      }

      let middlewareOptions = watchMiddlewareOptionsCallback(original, methodName)

      if (!middlewareOptions) {
        return original
      }

      return tracer.watch(original, watchOptionsCallback)

      function watchOptionsCallback (original, methodName, args) {
        let framework = Util.getPropertyFromObject(middlewareOptions, 'framework')
        let routeName = Util.getPropertyFromObject(middlewareOptions, 'routeName')

        let middlewareMethodName = Util.getPropertyFromObject(middlewareOptions, 'middlewareMethodName')
        let middlewareName = Util.getPropertyFromObject(middlewareOptions, 'middlewareName')
        let middlewareType = Util.getPropertyFromObject(middlewareOptions, 'middlewareType')
        let middlewareRequestObject = Util.getPropertyFromObject(middlewareOptions, 'middlewareRequestObject')
        let middlewareNextObject = Util.getPropertyFromObject(middlewareOptions, 'middlewareNextObject')
        let middlewareCheckArity = Util.getPropertyFromObject(middlewareOptions, 'middlewareCheckArity')
        let middlewareIsPromise = Util.getPropertyFromObject(middlewareOptions, 'middlewareIsPromise')
        // Set defaults
        let requestObject = Util.isFunction(middlewareRequestObject)
          ? middlewareRequestObject(original, methodName, args)
          : getRequestObjectFromArgs(middlewareRequestObject, args)

        if (!middlewareType) {
          middlewareType = MIDDLEWARE_TYPE.MIDDLEWARE
        }

        if (!framework) {
          framework = 'Not recorded'
        }

        if (!middlewareMethodName) {
          middlewareMethodName = '<undefined>'
        }

        let spanProperties = {
          'CATEGORY': 'Framework',
          'SUBCATEGORY': framework
        }

        if (routeName) {
          routeName = getRouteStringFromRoute(routeName)
          spanProperties['PATH'] = routeName
        }

        let transactionInfo = (requestObject && requestObject.txInfo) ? requestObject.txInfo : null
        let spanStack = (transactionInfo && transactionInfo.spanStack) ? transactionInfo.spanStack : null
        let parentSpan = (spanStack && spanStack[spanStack.length - 1]) || tracer.getActiveSpan()
        let spanCall = framework + '.' + middlewareType + '.' + middlewareMethodName + '.' + middlewareName
        let checkArity = !!middlewareCheckArity // Adds checking for function arity
        let isPromise = !!middlewareIsPromise
        let isErrorWare = middlewareType === MIDDLEWARE_TYPE.ERRORWARE // eslint-disable-line

        if (!parentSpan) {
          Logger.debug('Tracer.watchMiddleware - wrappedMiddlewareHalder - watchOptionsCallback - Parent Span is undefined')
        }

        let nextCallbackWrapper = isPromise ? makePushSpanCallback(transactionInfo) : null
        if (Util.isFunction(middlewareNextObject)) {
          nextCallbackWrapper = makeCallbackNextSpanBinder(transactionInfo, routeName, middlewareNextObject, isPromise)
        } else {
          let nextIndex = Util.normalizeIndex(args.length, middlewareNextObject)
          if (nextIndex !== null && Util.isFunction(args[nextIndex])) {
            nextCallbackWrapper = makeCallbackNextSpanBinder(transactionInfo, routeName, makeNextWrapperCallback(nextIndex), isPromise)
          }
        }
        return {
          createSpan: true,
          parentSpan: parentSpan,
          checkArity: checkArity,
          isPromiseResult: isPromise,
          spanCall: spanCall,
          spanProperties: spanProperties,
          callbackOptions: {
            wrapper: nextCallbackWrapper
          },
          hookOptions: {
            hookAfter: function hookAfter (original, args, methodName, activeSpan, result, err) {
              if (isPromise || (err || !nextCallbackWrapper)) {
                transactionInfo.spanStack.pop()
              }
              if (err) {
                tracer.addErrorToActiveTransaction(err)
              }
            }
          }
        }
      }
    }

    function makePushSpanCallback (transactionInfo) {
      return function pushSpanCallback (library, methodName, args, activeSpan) {
        transactionInfo.spanStack.push(activeSpan)
      }
    }

    function makeNextWrapperCallback (nextIndex) {
      return function nextWrapperCallback (library, methodName, args, activeSpan, bindNextWrapper) {
        bindNextWrapper(args, nextIndex)
      }
    }

    function makeCallbackNextSpanBinder (txInfo, routeName, nextWrapperCallback, isPromise) {
      return function callbackNextSpanBinder (library, methodName, args, activeSpan) {
        if (!activeSpan) {
          // No active span
          return
        }

        // Add active span stack
        txInfo.spanStack.push(activeSpan)
        nextWrapperCallback(library, methodName, args, activeSpan, bindNextWrapper)

        // Make next wrapper to be executed
        function bindNextWrapper (library, properties, isFinal) {
          if (Util.isFunction(properties)) {
            watchMiddlewareOptionsCallback = properties
            properties = null
          }

          if (properties && !Util.isArray(properties)) {
            properties = [properties]
          }

          if (properties === null) {
            return shimmer.wrap(library, null, wrappedNextWrapper)
          }

          // Wrap one by one
          properties.forEach(function callbackFn (value, index) {
            shimmer.wrap(library, value, wrappedNextWrapper)
          })

          return library

          function wrappedNextWrapper (next, methodName) {
            return tracer.bindSpanCallback(function boundNextWrapper () {
              let args = Util.argsToArray.apply(this, arguments)

              if (!isPromise) {
                txInfo.spanStack.pop()
                tracer.endSpan(activeSpan)
              }

              let result = next.apply(this, args)

              if (isPromise && Util.isPromise(result)) {
                return result.then(function onFulfilled (value) {
                  txInfo.spanStack.push(activeSpan)
                  return value
                })
              }
              return result
            }, tracer.getActiveSpan() || activeSpan)
          }
        }
      }
    }

    function getRouteStringFromRoute (route) {
      if (route instanceof RegExp) {
        return '/' + route.source + '/'
      }
      if (Util.isArray(route)) {
        return route.join(',')
      } else if (route[0] !== '/') {
        return '/' + route
      }

      return route
    }

    function getRequestObjectFromArgs (requestIndex, args) {
      if (!requestIndex) {
        Logger.debug('tracer.watchMiddleware - getRequestObjectFromArgs - Request Index is undefined or null')
        requestIndex = ARGS.FIRST // Default request indexs
      }

      let reqIdx = Util.normalizeIndex(args.length, requestIndex)
      if (reqIdx === null || !args[reqIdx]) {
        Logger.debug('tracer.watchMiddleware - getRequestObjectFromArgs - Can not find request parameter, not recording.')
        return null
      }
      return args[reqIdx]
    }
  }
}

Tracer.prototype.wrapClassFunctionPatchReturn = function wrapClassFunctionPatchReturn (library, properties, wrapClassPatchReturnOptions) {
  if (Util.isFunction(properties)) {
    wrapClassPatchReturnOptions = properties
    properties = null
  }

  if (properties && !Util.isArray(properties)) {
    properties = [properties]
  }

  if (properties === null) {
    return shimmer.wrap(library, null, wrapClassFunction)
  }

  // Wrap one by one
  properties.forEach(function callbackFn (value, index) {
    shimmer.wrap(library, value, wrapClassFunction)
  })

  return library

  function wrapClassFunction (original, name) {
    if (!Util.isFunction(original)) {
      return original
    }

    let hasPrototype = !!original.prototype
    wrappedClassFunction.prototype = original.prototype
    return wrappedClassFunction

    function wrappedClassFunction () {
      let args = Util.argsToArray.apply(this, arguments)
      let ret
      let context = this
      if (hasPrototype && this instanceof wrappedClassFunction) {
        context = ret = new (original.bind(original, args))()
      } else {
        ret = original.apply(context, args)
      }

      let patchReturnCallback = Util.getPropertyFromObject(wrapClassPatchReturnOptions, 'patchReturnCallback')
      if (patchReturnCallback && Util.isFunction(patchReturnCallback)) {
        let newRet = patchReturnCallback.call(context, ret, original, args)
        if (newRet) {
          ret = newRet
        }
      }

      return ret
    }
  }
}

/**
 * Get rum injection content from the rum generator
 */
Tracer.prototype.injectRumContent = function injectRumContent () {
  return this._rumGenerator.getRumInjectionContent()
}

module.exports = Tracer
