'use strict'
let glob = require('glob')
let fs = require('fs')
let path = require('path')
let Util = require('./../util')
let Common = require('./../common')
let Logger = require('./../logger')
/**
 * LogCleaner
 *
 * - Removes expired files based on the intervalMs set (default: 1 hour)
 * and worker loops every timeoutMs (default: 60 seconds)
 *
 * @class
 * @param {string} globPattern Glob file pattern (e.g *.log)
 * @param {string} directory Directory location of the files
 * @param {number} intervalMillis Elapsed duration of the log files to be removed
 * @param {number} timeoutMillis Log cleaner worker timeout (worker tick)
 * @param {string} logFileExtension Log file extension
 */
function LogCleaner (globPattern, directory, intervalMillis, timeoutMillis, logFileExtension) {
  this.setDirectory(directory || Common.LOG_TRACES_DIR)
  this.setLastRun(null)
  this.setNextRun(null)
  this.setTimeout(timeoutMillis || 60000)
  this.setGlobPattern(globPattern || '*.log')
  this.setLogFileExtension(logFileExtension || Common.LOG_FILE_EXTENSION)
  this.setInterval(intervalMillis || (60000 * 60)) // 60 minutes
  this.setRunning(false)
  this.setStop(true)
  this._runCount = 0
  this._stopCallback = null
}

/**
 * Starts the log cleaner
 */
LogCleaner.prototype.start = function start () {
  if (this.isRunning()) {
    Logger.debug('LogCleaner.start - Log cleaner has already started - Time: %s', this.getLastRun())
    return
  }

  let self = this
  this.setRunning(true)
  this.setStop(false)
  let timeout = null

  let stop = function () {
    if (!self.isRunning()) { // If not running, we assume callback has been called
      return
    }

    if (timeout) {
      clearTimeout(timeout)
    }

    self.setRunning(false) // Stop
    if (self._stopCallback) {
      self._stopCallback(self._runCount)
    }
  }

  let timerFunction = function () {
    if (self.hasStopped()) {
      return stop()
    }
    // Set timeout once the job is done
    self._runCount++
    self.run(function () {
      if (self.hasStopped()) {
        return stop()
      }
      timeout = setTimeout(timerFunction, self.getTimeout())
    })
  }

  timerFunction()
}

/**
 * Run log cleaner
 */
LogCleaner.prototype.run = function run (doneCallback) {
  let self = this
  let currentTime = new Date().getTime()
  if (
    this.getLastRun() === null ||
    this.getNextRun() === null ||
    (this.getNextRun() && (currentTime > this._nextRun))
  ) {
    this.deleteFiles(function done () {
      self.setLastRun(new Date().getTime())
      self.setNextRun(self.getLastRun() + self.getInterval())
      doneCallback()
    })
  } else {
    // Do nothing, ignore as next run was set already
    return doneCallback()
  }
}

/**
 * Set running state
 */
LogCleaner.prototype.setRunning = function setRunning (running) {
  this._running = running
}

/**
 * Get running state
 */
LogCleaner.prototype.isRunning = function isRunning () {
  return this._running
}

/**
 * Stop cleaner
 */
LogCleaner.prototype.stop = function stop (stopCallback) {
  this.setStop(true)
  this.setStopCallback(stopCallback)
}

/**
 * Set stop callback to be called after running
 */
LogCleaner.prototype.setStopCallback = function setStopCallback (stopCallback) {
  if (!stopCallback) {
    Logger.debug('LogCleaner.setStopCallback - Callback provided is empty')
    return
  }

  if (!Util.isFunction(stopCallback)) {
    Logger.debug('LogCleaner.setStopCallback - Callback is not a function')
    return
  }

  this._stopCallback = stopCallback
}

/**
 * Set stop state
 */
LogCleaner.prototype.setStop = function setStop (stop) {
  this._stop = stop
}

/**
 * Get stop state
 */
LogCleaner.prototype.hasStopped = function hasStopped () {
  return this._stop
}

/**
 * Get timeout
 */
LogCleaner.prototype.getTimeout = function getTimeout () {
  return this._timeout
}

/**
 * Set timeout
 */
LogCleaner.prototype.setTimeout = function setTimeout (timeout) {
  this._timeout = timeout
}

/**
 * Get interval
 */
LogCleaner.prototype.getInterval = function getInterval () {
  return this._interval
}

/**
 * Set interval
 */
LogCleaner.prototype.setInterval = function setInterval (interval) {
  this._interval = interval
}

/**
 * Get last run
 */
LogCleaner.prototype.getLastRun = function getLastRun () {
  return this._lastRun
}

/**
 * Set last run
 */
LogCleaner.prototype.setLastRun = function setLastRun (lastRun) {
  this._lastRun = lastRun
}

/**
 * Get next run
 */
LogCleaner.prototype.getNextRun = function getNextRun () {
  return this._nextRun
}

/**
 * Set last run
 */
LogCleaner.prototype.setNextRun = function setNextRun (nextRun) {
  this._nextRun = nextRun
}

/**
 * Get glob pattern
 */
LogCleaner.prototype.getGlobPattern = function getGlobPattern () {
  return this._globPattern
}

/**
 * Set glob pattern
 */
LogCleaner.prototype.setGlobPattern = function setGlobPattern (globPattern) {
  if (!globPattern) {
    throw new Error('LogCleaner.setGlobPattern - Glob pattern is required')
  }

  if (!Util.isString(globPattern)) {
    throw new Error('LogCleaner.setGlobPattern - Glob pattern must be a string')
  }

  this._globPattern = globPattern
}

/**
 * Get log file extension
 */
LogCleaner.prototype.getLogFileExtension = function getLogFileExtension () {
  return this._logFileExtension
}

/**
 * Set log file extension
 */
LogCleaner.prototype.setLogFileExtension = function setLogFileExtension (logFileExtension) {
  if (!logFileExtension) {
    throw new Error('LogCleaner.setLogFileExtension - Log extension is required')
  }

  if (!Util.isString(logFileExtension)) {
    throw new Error('LogCleaner.setLogFileExtension - Log extension must be a string')
  }

  this._logFileExtension = logFileExtension
}

/**
 * Get directory
 */
LogCleaner.prototype.getDirectory = function getDirectory () {
  return this._directory
}

/**
 * Set directory
 */
LogCleaner.prototype.setDirectory = function setDirectory (directory) {
  if (!directory) {
    throw new Error('LogCleaner.setDirectory - Directory is required')
  }

  if (!Util.isString(directory)) {
    throw new Error('LogCleaner.setDirectory - Directory must be a string')
  }

  this._directory = directory
}

/**
 * Delete files on directory
 */
LogCleaner.prototype.deleteFiles = function (doneCallback) {
  let self = this

  Logger.debug('LogCleaner.deleteFiles - Starting Log cleaner')
  glob(this.getGlobPattern(), {
    cwd: this.getDirectory(),
    nodir: true
  }, function (er, files) {
    if (er) {
      Logger.debug('LogCleaner.deleteFiles -> glob - Error occured - Error: %s', er.message)
      return doneCallback()
    }

    let promises = []
    Logger.debug('LogCleaner.deleteFiles - Files for deletion: %s ', JSON.stringify(files))
    files.forEach(function (fileName, index) {
      if (fileName.indexOf(Common.LOG_FILE_BASE_NAME + self.getLogFileExtension()) !== -1) {
        Logger.debug('LogCleaner.deleteFiles -> glob - Ignoring stackify-node-apm log file - File: %s', fileName)
        return
      }
      let currentTimeMs = new Date().getTime() // Cache timestamp the deletion has started
      promises.push(new Promise(function (resolve, reject) {
        let fileLocation = path.join(self.getDirectory(), fileName)
        fs.stat(fileLocation, function (err, stats) {
          if (err) {
            Logger.debug('LogCleaner.deleteFiles -> glob -> fs.stat - Error occured - File: %s - Error: %s', fileName, err.message)
            return resolve()
          }

          if (!stats) {
            Logger.debug('LogCleaner.deleteFiles -> glob -> fs.stat -> Empty stats - File: %s', fileName)
            return resolve()
          }
          // Current time in MS diff with file modified date
          let timeDiff = currentTimeMs - stats.mtime.getTime()
          if (timeDiff > self.getInterval()) {
            fs.unlink(fileLocation, function unlink (errUnlink) {
              if (errUnlink) {
                Logger.debug('LogCleaner.deleteFiles -> glob -> fs.stat -> Expired File -> fs.unlink - Error occured - File: %s - Error: %s', fileName, errUnlink.message)
                return resolve()
              }

              Logger.debug('LogCleaner.deleteFiles -> glob -> fs.stat -> Expired File -> Successfully removed file - File: %s', fileName)
              return resolve()
            })
          } else {
            Logger.debug('LogCleaner.deleteFiles -> glob -> fs.stat -> File not expired - File: %s ', fileLocation)
            return resolve()
          }
        })
      }))
    })

    // We are not expecting any errors to be thrown but just a failsafe, dont stop the execution
    if (!files) {
      Logger.debug('LogCleaner.deleteFiles -> glob -> No files')
      return doneCallback()
    } else {
      Promise.all(promises)
        .then(function () {
          Logger.debug('LogCleaner.deleteFiles - Ending log cleaner')
          doneCallback()
        }).catch(function (err) {
          Logger.debug('LogCleaner.deleteFiles -> Promise.all -> Catch Error: %s', err.message)
          doneCallback()
        })
    }
  })
}

module.exports = LogCleaner
