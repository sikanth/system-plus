'use strict'
const Util = require('../util')
const Logger = require('../logger')

/**
 * Queue option to be passed on Queue constructor
 * @typedef {Object} QueueOptions
 * @property {string} onLimit - Triggered when the queue reaches it limit
 * @property {string} onCheck - Triggered before adding an item to the queue
 * @property {number} maxQueueSize - Max Queue items to store in cache
 * @property {number} flushIntervalMillis - Interval before the queue flushes
 * @property {number} name - Name of the queue (in case there are different approaches)
 */

/**
 * @callback onFlushCallback
 * @param {array} queueItems - Pass the current queue items on flush callback
 * @param {callback} onFlushDoneCallback - Callback that can be triggered by onFlush callback
 * @param {callback} setClearOnFlush - Set clear flag after flushing
 * @param {callback} resetTimer - Helper - clears queue items and timer and re-sets it
 * @param {callback} clearTimer - Helper - clears queue timer
 * @param {callback} filterItems - Queue._filterItems proxy
 */

/**
 * Simple Queue for transactions
 * @param {QueueOptions|onFlushCallback} options function to call when flush is called (passes in array of items and callback)
 * @type {Queue}
 */
function Queue (options) {
  this._name = 'Queue'

  if (typeof options === 'undefined') {
    throw new Error(this._name + ': no options or flush callback has been set')
  }

  if (Util.isFunction(options)) {
    options = {
      onFlush: options
    }
  }

  if (!Util.isFunction(options.onFlush)) {
    throw new Error(this._name + ': no flush callback has been set')
  }

  options = Object.assign({
    onLimit: undefined,
    onCheck: undefined,
    maxQueueSize: 20,
    flushIntervalMillis: 250,
    name: 'Queue'
  }, options)
  this._name = options.name || this._name

  this._onFlush = options.onFlush

  this._flushIntervalMillis = options.flushIntervalMillis
  if (this._flushIntervalMillis === undefined || (!Util.isUndefined(this._flushIntervalMillis) && !Util.isNumber(this._flushIntervalMillis))) {
    throw new Error(this._name + ':flushIntervalMillis is not an integer')
  } else if (this._flushIntervalMillis < 0) {
    throw new Error(this._name + ':flushIntervalMillis is less than 0')
  }

  this._maxQueueSize = options.maxQueueSize
  if (this._maxQueueSize === undefined || (!Util.isUndefined(this._maxQueueSize) && !Util.isNumber(this._maxQueueSize))) {
    throw new Error(this._name + ':maxQueueSize is not a number')
  } else if (this._maxQueueSize < 1) {
    throw new Error(this._name + ':maxQueueSize is less than 1')
  }

  this._onLimit = options.onLimit
  if (!Util.isUndefined(this._onLimit) && !Util.isFunction(this._onLimit)) {
    throw new Error(this._name + ':constructor limit callback has been set but not a valid function')
  }

  this._onCheck = options.onCheck
  if (!Util.isUndefined(this._onCheck) && !Util.isFunction(this._onCheck)) {
    throw new Error(this._name + ':constructor check callback has been set but not a valid function')
  }

  this._items = []
  this._timeout = null

  Logger.debug(this._name + ':constructor - setting up queue')
}

/**
 * Add item to queue
 * @param obj
 */
Queue.prototype.add = function (obj) {
  let self = this
  Logger.debug(this._name + ':add - add item to queue - ' + (obj && obj.id && obj.id()))
  if (this._items.indexOf(obj) !== -1) {
    Logger.debug(this._name + ':add - item already exist in the queue, ignoring')
    return null
  }

  // If does not pass on check, process
  let checked = true
  // Check before adding
  if (this._onCheck) {
    checked = this._onCheck(obj)
  }

  if (!checked) {
    // Not valid for queueing
    Logger.debug(this._name + ':add - item not valid for queuing - ' + (obj && obj.id && obj.id()))
    return false
  }

  this._items.push(obj)
  if (this._items.length >= this._maxQueueSize) {
    if (this._onLimit) {
      // use the onLimit handler on what to do next and pass the internal flush
      // on WaitQueue, we pluck the first item instead of flushing
      Logger.debug(this._name + ':add - trigger on limit callback')
      this._onLimit(
        this._items,
        // Flush and clear everything
        function internalFlush (cb, clearOnFlush) {
          self.flush(cb, clearOnFlush)
        }
      )
    } else {
      // default flush if the max limit has been reached
      Logger.debug(this._name + ':add - use default flush - ' + (obj && obj.id && obj.id()))
      this.flush()
    }
  } else if (!this._timeout) {
    // If timeout has been cleared, resetup the timer
    Logger.debug(this._name + ':add - set flush timer - ' + (obj && obj.id && obj.id()))
    this._setFlushTimer()
  }

  return true
}

/**
 * Flush Queue immediately
 * @param {callback?} cb - (Optional) - Can be triggered
 * @param {callback} clearOnFlush - Allow to set clear flush flag indirectly
 */
Queue.prototype.flush = function (cb, clearOnFlush) {
  Logger.debug(this._name + ':flush - processing queue items')
  let self = this
  if (!Util.isFunction(cb) && !Util.isUndefined(cb)) {
    clearOnFlush = cb
    cb = undefined
  }

  this._onFlush(
    this._items,
    cb || noop,
    function setClearOnFlush (_clearOnFlush) { // Responsible for if to clear on flush
      clearOnFlush = _clearOnFlush
    },
    function resetTimer () { // Give access to reset timer (clear and set new one)
      self._resetTimer()
    },
    function clearTimer () { // Just clear the timer
      self._clearTimer()
    },
    this._filterItems.bind(this) // Pass the queue-object for item manipulation
  )

  if (clearOnFlush) {
    this._clear()
  }
}

/**
 * Clear queue timeout and process the items in the queue with a custom flush callback
 * @param {callback} overrideCallback - (Optional) - Can be triggered
 */
Queue.prototype.forceClearAndCustomFlush = function (customFlushCallback) {
  Logger.debug(this._name + ':forceClearAndCustomFlush - processing queue items')
  let self = this

  if (!Util.isFunction(customFlushCallback)) {
    Logger.error(this._name + ':forceClearAndCustomFlush - callback is not a function, not processing')
    return
  }

  self._clearTimer()
  customFlushCallback(this._items)
  this._items = []
}

/**
 * Set Flush Queue w/ Timeout
 * @private
 */
Queue.prototype._setFlushTimer = function () {
  const self = this
  this._timeout = setTimeout(function () {
    self.flush()
  }, this._flushIntervalMillis)
  this._timeout.unref()
}

/**
 * Clear Queue
 * @private
 */
Queue.prototype._clear = function () {
  this._clearTimer()
  this._items = []
}

Queue.prototype._clearTimer = function _clearTimer () {
  clearTimeout(this._timeout)
  this._timeout = null
}

Queue.prototype._resetTimer = function _resetTimer () {
  Logger.debug(this._name + ':_resetTimer - timer has been cleared and re-set')
  this._clearTimer()
  this._setFlushTimer()
}
/**
 * Filter queue items and execute removeCallback for removed items
 * @param {callback} filterCallback - Checking for items to be removed
 * @param {callback} removeCallback - Executed once an item has been removed
 * @returns {Number} - Number of removed items
 */
Queue.prototype._filterItems = function _filterItems (filterCallback, removeCallback) {
  if (!Util.isFunction(filterCallback)) {
    throw new Error(this._name + ': no filter callback has been set')
  }
  if (!Util.isUndefined(removeCallback) && !Util.isFunction(removeCallback)) {
    throw new Error(this._name + ': no remove callback has been set')
  }

  let toBeRemoved = []
  this._items.forEach(function forEachCallback (value, index) {
    if (filterCallback(value)) {
      toBeRemoved.push(index)
    }
  })

  if (toBeRemoved.length) {
    multisplice(this._items, toBeRemoved, removeCallback)
  }

  // Reference: http://blog.moagrius.com/actionscript/javascript-splice-array-on-multiple-indices-multisplice/
  function multisplice (items, _toBeRemoved, _removeCallback) {
    _toBeRemoved.sort(function sortCallback (a, b) {
      return a - b
    })
    for (let i = 0; i < _toBeRemoved.length; i++) {
      let index = _toBeRemoved[i] - i
      let removedItem = items.splice(index, 1)
      if (Util.isFunction(_removeCallback)) {
        if (!Util.isArray(removedItem)) {
          removedItem = [removedItem]
        }
        removedItem.forEach(function removedItemCallback (value, index) {
          _removeCallback(value, _toBeRemoved[i])
        })
      }
    }
  }

  return toBeRemoved.length
}

/**
 * Get queue items
 */
Queue.prototype.getItems = function getItems () {
  return this._items
}
module.exports = Queue

function noop () {

}
