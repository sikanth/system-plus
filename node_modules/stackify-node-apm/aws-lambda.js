'use strict'

const Util = require('./lib/util')
const Profiler = require('./lib/profiler')
const Config = require('./lib/config')
const process = require('process')

const config = new Config()
config.queueEnabled = false
config.transport = 'logging'

const profiler = (new Profiler(true, config)).start()

var StackifyLambda = {

  endTransaction: function (context, error) {
    // end current span (may still be open when using callbacks)
    let activeSpan = profiler.tracer.getActiveSpan()
    if (activeSpan) {
      profiler.tracer.endSpan(activeSpan)
    }

    let rootSpan = profiler.tracer.getActiveRootSpan()
    rootSpan = profiler.tracer.getActiveRootSpan()
    rootSpan.addProperty('AWS_LAMBDA_ARN', context.invokedFunctionArn)
    rootSpan.addProperty('REPORTING_URL', context.functionName)
    rootSpan.addProperty('TRACETYPE', 'TASK')

    // add error from callback if present
    if (error) {
      rootSpan.addException(error)
    }

    profiler.tracer.endTransaction()
  },

  getWrappedCallback: function (originalCallback, context, thisArg) {
    if (originalCallback) {
      return function () {
        let result = originalCallback.apply(thisArg, arguments)
        StackifyLambda.endTransaction.apply(thisArg, [ context, null ])
        return result
      }
    }
    return originalCallback
  },

  getWrappedFunction: function () {
    var envLambdaHandler = StackifyLambda.getStackifyLambdaHandler()
    var path = process.cwd()
    var lambdaHandler = envLambdaHandler.split('.')
    var lambdaHandlerFilename = lambdaHandler[0]
    var lambdaHandlerFunctionName = lambdaHandler[1]
    var lambdaHandlerAbsolutePath = path + '/' + lambdaHandlerFilename
    var lambdaHandlerTarget = require(lambdaHandlerAbsolutePath)

    return lambdaHandlerTarget[lambdaHandlerFunctionName]
  },

  getStackifyLambdaHandler: function () {
    return process.env.STACKIFY_LAMBDA_HANDLER
  },

  checkRequiredParameters: function (event, context) {
    if (!event || !context) {
      throw new Error('Both `event` and `context` parameters are required for lambda handler.')
    }

    if (Util.isUndefined(process.env.STACKIFY_LAMBDA_HANDLER)) {
      throw new Error('Your environment variable STACKIFY_LAMBDA_HANDLER is missing.')
    }
  }

}

/**
 * <stackify_handler> - handler is a Lambda function that processes events
 * @param {array} event - contains information from the invoker.
 * @param {boolean} context - contains information about the invocation, function and execution environment.
 * @param callback
 */
exports.stackify_handler = function (event, context, callback) {
  var wrappedFunction, wrappedCallback

  try {
    StackifyLambda.checkRequiredParameters(event, context)
    wrappedFunction = StackifyLambda.getWrappedFunction()
    wrappedCallback = StackifyLambda.getWrappedCallback(callback, context, this)
  } catch (error) {
    throw error
  }

  return profiler.tracer.runInTransaction(StackifyLambda.getStackifyLambdaHandler(), function wrapSampleTransaction () {
    let wrappedFunctionResult, wrappedFunctionError

    try {
      wrappedFunctionResult = wrappedFunction(event, context, wrappedCallback)
    } catch (error) {
      wrappedFunctionError = error
    }

    if (!wrappedCallback) {
      StackifyLambda.endTransaction(context, wrappedFunctionError)
    }

    if (wrappedFunctionError) {
      throw wrappedFunctionError
    }

    return wrappedFunctionResult
  }).apply(this, arguments)
}

/**
 * <stackify_handler_async> - handler is a Lambda async function that processes events
 * @param {array} event - contains information from the invoker.
 * @param {boolean} context - contains information about the invocation, function and execution environment.
 */
exports.stackify_handler_async = async function (event, context) {
  var wrappedFunction

  try {
    StackifyLambda.checkRequiredParameters(event, context)
    wrappedFunction = StackifyLambda.getWrappedFunction()
  } catch (error) {
    throw error
  }

  return profiler.tracer.runInTransaction(StackifyLambda.getStackifyLambdaHandler(), async function wrapSampleTransaction () {
    let wrappedFunctionResult, wrappedFunctionError

    try {
      wrappedFunctionResult = await wrappedFunction(event, context)
    } catch (error) {
      wrappedFunctionError = error
    }

    StackifyLambda.endTransaction(context, wrappedFunctionError)

    if (wrappedFunctionError) {
      throw wrappedFunctionError
    }

    return wrappedFunctionResult
  }).apply(this, arguments)
}
